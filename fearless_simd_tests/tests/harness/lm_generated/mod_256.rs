//! Expanded test suite generated by Claude Code based on mod.rs
//!
//! This file contains tests for 256-bit and 512-bit vector operations that correspond to
//! existing 128-bit vector tests in mod.rs.
//!
//! In the future we might want to add a more rigorous automatic generation
//! of test cases for various vector sizes, but this is a simple first step
//! towards increased test coverage.

// Copyright 2026 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

use fearless_simd::*;
use fearless_simd_dev_macros::simd_test;

// =============================================================================
// f32x8 tests (256-bit equivalents of f32x4 tests)
// =============================================================================

#[simd_test]
fn splat_f32x8<S: Simd>(simd: S) {
    let a = f32x8::splat(simd, 4.2);
    assert_eq!(*a, [4.2, 4.2, 4.2, 4.2, 4.2, 4.2, 4.2, 4.2]);
}

#[simd_test]
fn abs_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[-1.0, 2.0, -3.0, 4.0, -5.0, 6.0, -7.0, 8.0]);
    assert_eq!(*a.abs(), [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
}

#[simd_test]
fn neg_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, -2.0, 3.0, -4.0, 5.0, -6.0, 7.0, -8.0]);
    assert_eq!(*(-a), [-1.0, 2.0, -3.0, 4.0, -5.0, 6.0, -7.0, 8.0]);
}

#[simd_test]
fn add_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0]);
    assert_eq!(*(a + b), [11.0, 22.0, 33.0, 44.0, 55.0, 66.0, 77.0, 88.0]);
}

#[simd_test]
fn sub_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0]);
    let b = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
    assert_eq!(*(a - b), [9.0, 18.0, 27.0, 36.0, 45.0, 54.0, 63.0, 72.0]);
}

#[simd_test]
fn mul_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]);
    assert_eq!(*(a * b), [2.0, 6.0, 12.0, 20.0, 30.0, 42.0, 56.0, 72.0]);
}

#[simd_test]
fn sqrt_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 0.0, 1.0, 2.0, 9.0, 16.0, 25.0, 36.0]);
    assert_eq!(
        *f32x8::sqrt(a),
        [2.0, 0.0, 1.0, f32::sqrt(2.0), 3.0, 4.0, 5.0, 6.0]
    );
}

#[simd_test]
fn div_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 2.0, 1.0, 0.0, 10.0, 12.0, 15.0, 20.0]);
    let b = f32x8::from_slice(simd, &[4.0, 1.0, 3.0, 0.1, 2.0, 3.0, 5.0, 4.0]);
    assert_eq!(*(a / b), [1.0, 2.0, 1.0 / 3.0, 0.0, 5.0, 4.0, 3.0, 5.0]);
}

#[simd_test]
fn copysign_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, -2.0, -3.0, 4.0, -5.0, 6.0, 7.0, -8.0]);
    let b = f32x8::from_slice(simd, &[-1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0]);
    assert_eq!(*a.copysign(b), [-1.0, 2.0, -3.0, 4.0, 5.0, -6.0, -7.0, 8.0]);
}

#[simd_test]
fn simd_eq_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 2.0, 1.0, 0.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[4.0, 3.1, 1.0, 0.0, 5.0, 7.0, 7.0, 9.0]);
    assert_eq!(*a.simd_eq(b), [-1, 0, -1, -1, -1, 0, -1, 0]);
}

#[simd_test]
fn simd_lt_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 3.0, 2.0, 1.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[1.0, 2.0, 2.0, 4.0, 10.0, 5.0, 8.0, 7.0]);
    assert_eq!(*a.simd_lt(b), [0, 0, 0, -1, -1, 0, -1, 0]);
}

#[simd_test]
fn simd_le_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 3.0, 2.0, 1.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[1.0, 2.0, 2.0, 4.0, 5.0, 6.0, 8.0, 7.0]);
    assert_eq!(*a.simd_le(b), [0, 0, -1, -1, -1, -1, -1, 0]);
}

#[simd_test]
fn simd_ge_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 3.0, 2.0, 1.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[1.0, 2.0, 2.0, 4.0, 5.0, 6.0, 8.0, 7.0]);
    assert_eq!(*a.simd_ge(b), [-1, -1, -1, 0, -1, -1, 0, -1]);
}

#[simd_test]
fn simd_gt_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[4.0, 3.0, 2.0, 1.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[1.0, 2.0, 2.0, 4.0, 5.0, 6.0, 8.0, 7.0]);
    assert_eq!(*a.simd_gt(b), [-1, -1, 0, 0, 0, 0, 0, -1]);
}

#[simd_test]
fn madd_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, -2.0, 7.0, 3.0, 2.0, 4.0, 5.0, 6.0]);
    let b = f32x8::from_slice(simd, &[5.0, 4.0, 100.0, 8.0, 3.0, 5.0, 6.0, 7.0]);
    let c = f32x8::from_slice(simd, &[2.0, -3.0, 0.0, 0.5, 1.0, 2.0, 3.0, 4.0]);
    assert_eq!(
        *a.mul_add(b, c),
        [7.0, -11.0, 700.0, 24.5, 7.0, 22.0, 33.0, 46.0]
    );
}

#[simd_test]
fn max_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, -3.0, 0.0, 0.5, 1.0, 5.0, 3.0, 7.0]);
    let b = f32x8::from_slice(simd, &[1.0, -2.0, 7.0, 3.0, 2.0, 4.0, 6.0, 5.0]);
    assert_eq!(*a.max(b), [2.0, -2.0, 7.0, 3.0, 2.0, 5.0, 6.0, 7.0]);
}

#[simd_test]
fn min_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, -3.0, 0.0, 0.5, 1.0, 5.0, 3.0, 7.0]);
    let b = f32x8::from_slice(simd, &[1.0, -2.0, 7.0, 3.0, 2.0, 4.0, 6.0, 5.0]);
    assert_eq!(*a.min(b), [1.0, -3.0, 0.0, 0.5, 1.0, 4.0, 3.0, 5.0]);
}

#[simd_test]
fn max_precise_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, -3.0, 0.0, 0.5, 1.0, 5.0, 3.0, 7.0]);
    let b = f32x8::from_slice(simd, &[1.0, -2.0, 7.0, 3.0, 2.0, 4.0, 6.0, 5.0]);
    assert_eq!(*a.max_precise(b), [2.0, -2.0, 7.0, 3.0, 2.0, 5.0, 6.0, 7.0]);
}

#[simd_test]
fn min_precise_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, -3.0, 0.0, 0.5, 1.0, 5.0, 3.0, 7.0]);
    let b = f32x8::from_slice(simd, &[1.0, -2.0, 7.0, 3.0, 2.0, 4.0, 6.0, 5.0]);
    assert_eq!(*a.min_precise(b), [1.0, -3.0, 0.0, 0.5, 1.0, 4.0, 3.0, 5.0]);
}

#[simd_test]
fn msub_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]);
    let b = f32x8::from_slice(simd, &[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]);
    let c = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
    assert_eq!(
        *a.mul_sub(b, c),
        [19.0, 28.0, 37.0, 46.0, 55.0, 64.0, 73.0, 82.0]
    );
}

#[simd_test]
fn max_precise_f32x8_with_nan<S: Simd>(simd: S) {
    let a = f32x8::from_slice(
        simd,
        &[f32::NAN, -3.0, f32::INFINITY, 0.5, 1.0, f32::NAN, 3.0, 7.0],
    );
    let b = f32x8::from_slice(
        simd,
        &[
            1.0,
            f32::NAN,
            7.0,
            f32::NEG_INFINITY,
            f32::NAN,
            4.0,
            6.0,
            5.0,
        ],
    );
    let result = a.max_precise(b);

    assert_eq!(result[0], 1.0);
    assert_eq!(result[1], -3.0);
    assert_eq!(result[2], f32::INFINITY);
    assert_eq!(result[3], 0.5);
    assert_eq!(result[4], 1.0);
    assert_eq!(result[5], 4.0);
    assert_eq!(result[6], 6.0);
    assert_eq!(result[7], 7.0);
}

#[simd_test]
fn min_precise_f32x8_with_nan<S: Simd>(simd: S) {
    let a = f32x8::from_slice(
        simd,
        &[f32::NAN, -3.0, f32::INFINITY, 0.5, 1.0, f32::NAN, 3.0, 7.0],
    );
    let b = f32x8::from_slice(
        simd,
        &[
            1.0,
            f32::NAN,
            7.0,
            f32::NEG_INFINITY,
            f32::NAN,
            4.0,
            6.0,
            5.0,
        ],
    );
    let result = a.min_precise(b);

    assert_eq!(result[0], 1.0);
    assert_eq!(result[1], -3.0);
    assert_eq!(result[2], 7.0);
    assert_eq!(result[3], f32::NEG_INFINITY);
    assert_eq!(result[4], 1.0);
    assert_eq!(result[5], 4.0);
    assert_eq!(result[6], 3.0);
    assert_eq!(result[7], 5.0);
}

#[simd_test]
fn floor_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.0, -3.2, 0.0, 0.5, 1.7, -2.8, 3.1, -4.9]);
    assert_eq!(*a.floor(), [2.0, -4.0, 0.0, 0.0, 1.0, -3.0, 3.0, -5.0]);
}

#[simd_test]
fn ceil_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.1, -3.2, -2.7, 0.5, 1.1, -2.9, 3.0, -4.1]);
    assert_eq!(*a.ceil(), [3.0, -3.0, -2.0, 1.0, 2.0, -2.0, 3.0, -4.0]);
}

#[simd_test]
fn round_ties_even_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.3, -3.2, 2.7, -3.6, -3.5, -2.5, 1.5, 0.5]);
    assert_eq!(
        *a.round_ties_even(),
        [2.0, -3.0, 3.0, -4.0, -4.0, -2.0, 2.0, 0.0]
    );
}

#[simd_test]
fn fract_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.7, -2.3, 3.9, -4.1, 5.5, -6.6, 7.2, -8.8]);
    let result = simd.fract_f32x8(a);
    assert_eq!(
        *result,
        [
            0.70000005,
            -0.29999995,
            0.9000001,
            -0.099999905,
            0.5,
            -0.5999999,
            0.19999981, // 7.2 - 7.0 has precision differences
            -0.8000002
        ]
    );
}

#[simd_test]
fn trunc_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[2.9, -3.2, 0.0, 0.5, 1.8, -2.7, 3.1, -4.9]);
    assert_eq!(*a.trunc(), [2.0, -3.0, 0.0, 0.0, 1.0, -2.0, 3.0, -4.0]);
}

#[simd_test]
fn trunc_f32x8_special_values<S: Simd>(simd: S) {
    let a = f32x8::from_slice(
        simd,
        &[
            f32::NAN,
            f32::NEG_INFINITY,
            f32::INFINITY,
            -f32::NAN,
            f32::NAN,
            f32::NEG_INFINITY,
            f32::INFINITY,
            -f32::NAN,
        ],
    );
    let result = a.trunc();

    // Note: f32::NAN != f32::NAN hence we transmute to compare the bit pattern
    unsafe {
        assert_eq!(
            std::mem::transmute::<[f32; 8], [u32; 8]>(*result),
            std::mem::transmute::<[f32; 8], [u32; 8]>([
                f32::NAN,
                f32::NEG_INFINITY,
                f32::INFINITY,
                -f32::NAN,
                f32::NAN,
                f32::NEG_INFINITY,
                f32::INFINITY,
                -f32::NAN
            ])
        );
    }
}

#[simd_test]
fn select_f32x8<S: Simd>(simd: S) {
    let a = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
    let b = f32x8::from_slice(simd, &[10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0]);
    let mask = mask32x8::from_slice(simd, &[-1, 0, -1, 0, 0, -1, 0, -1]);
    assert_eq!(
        *mask.select(a, b),
        [1.0, 20.0, 3.0, 40.0, 50.0, 6.0, 70.0, 8.0]
    );
}

// =============================================================================
// i8x32 tests (256-bit equivalents of i8x16 tests)
// =============================================================================

#[simd_test]
fn and_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
            0, -1, 0, -1, 0, -1, 0,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
            85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
        ],
    );
    assert_eq!(
        *(a & b),
        [
            85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85, 0, 85,
            0, 85, 0, 85, 0, 85, 0
        ]
    );
}

#[simd_test]
fn or_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, -1, -2, -3, -4, -5, -6, -7, -8, 0, 1, 2, 3, 4, 5, 6, 7, -1, -2,
            -3, -4, -5, -6, -7, -8,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
    );
    assert_eq!(
        *(a | b),
        [
            1, 1, 3, 3, 6, 7, 6, 7, -1, -2, -3, -4, -5, -6, -7, -8, 1, 1, 3, 3, 6, 7, 6, 7, -1, -2,
            -3, -4, -5, -6, -7, -8
        ]
    );
}

#[simd_test]
fn xor_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1,
            -1, 0, 0, 0, 0,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            -1, -1, 0, 0, 5, 4, 7, 6, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, 5, 4, 7, 6, -1, 0,
            -1, 0, -1, 0, -1, 0,
        ],
    );
    assert_eq!(
        *(a ^ b),
        [
            -1, -2, 2, 3, 1, 1, 1, 1, 0, -1, 0, -1, -1, 0, -1, 0, -1, -2, 2, 3, 1, 1, 1, 1, 0, -1,
            0, -1, -1, 0, -1, 0
        ]
    );
}

#[simd_test]
fn not_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, -1, -2, -3, -4, -5, -6, -7, -8, 0, 1, 2, 3, 4, 5, 6, 7, -1, -2,
            -3, -4, -5, -6, -7, -8,
        ],
    );
    assert_eq!(
        *(!a),
        [
            -1, -2, -3, -4, -5, -6, -7, -8, 0, 1, 2, 3, 4, 5, 6, 7, -1, -2, -3, -4, -5, -6, -7, -8,
            0, 1, 2, 3, 4, 5, 6, 7
        ]
    );
}

#[simd_test]
fn add_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, -1, -2, -3, -4, -5, -6, -7, -8, 1, 2, 3, 4, 5, 6, 7, 8, -1, -2,
            -3, -4, -5, -6, -7, -8,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 1, 2, 3, 4, 5, 6, 7, 8, 10, 20, 30, 40, 50, 60, 70, 80,
            1, 2, 3, 4, 5, 6, 7, 8,
        ],
    );
    assert_eq!(
        *(a + b),
        [
            11, 22, 33, 44, 55, 66, 77, 88, 0, 0, 0, 0, 0, 0, 0, 0, 11, 22, 33, 44, 55, 66, 77, 88,
            0, 0, 0, 0, 0, 0, 0, 0
        ]
    );
}

#[simd_test]
fn sub_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 0, 0, 0, 0, 0, 0, 0, 0, 10, 20, 30, 40, 50, 60, 70, 80,
            0, 0, 0, 0, 0, 0, 0, 0,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5,
            6, 7, 8,
        ],
    );
    assert_eq!(
        *(a - b),
        [
            9, 18, 27, 36, 45, 54, 63, 72, -1, -2, -3, -4, -5, -6, -7, -8, 9, 18, 27, 36, 45, 54,
            63, 72, -1, -2, -3, -4, -5, -6, -7, -8
        ]
    );
}

#[simd_test]
fn neg_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16, 17, -18, 19, -20, 21,
            -22, 23, -24, 25, -26, 27, -28, 29, -30, 31, -32,
        ],
    );
    assert_eq!(
        *(-a),
        [
            -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14, -15, 16, -17, 18, -19, 20, -21,
            22, -23, 24, -25, 26, -27, 28, -29, 30, -31, 32
        ]
    );
}

#[simd_test]
fn simd_eq_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5,
            6, 7, 8,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            1, 0, 3, 0, 5, 0, 7, 0, 1, 0, 3, 0, 5, 0, 7, 0, 1, 0, 3, 0, 5, 0, 7, 0, 1, 0, 3, 0, 5,
            0, 7, 0,
        ],
    );
    assert_eq!(
        *a.simd_eq(b),
        [
            -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
            0, -1, 0, -1, 0, -1, 0
        ]
    );
}

#[simd_test]
fn simd_lt_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, -1, -2, -3, -4, 10, 20, 30, 40, 50, 60, 70, 80, 1, 2, 3, 4, -1, -2, -3, -4,
            10, 20, 30, 40, 50, 60, 70, 80,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            2, 2, 2, 5, 0, 0, 0, 0, 5, 25, 25, 45, 45, 65, 65, 85, 2, 2, 2, 5, 0, 0, 0, 0, 5, 25,
            25, 45, 45, 65, 65, 85,
        ],
    );
    assert_eq!(
        *a.simd_lt(b),
        [
            -1, 0, 0, -1, -1, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, -1, -1, -1, -1, -1,
            0, -1, 0, -1, 0, -1, 0, -1
        ]
    );
}

#[simd_test]
fn simd_gt_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            2, 2, 2, 5, 0, 0, 0, 0, 5, 25, 25, 45, 45, 65, 65, 85, 2, 2, 2, 5, 0, 0, 0, 0, 5, 25,
            25, 45, 45, 65, 65, 85,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, -1, -2, -3, -4, 10, 20, 30, 40, 50, 60, 70, 80, 1, 2, 3, 4, -1, -2, -3, -4,
            10, 20, 30, 40, 50, 60, 70, 80,
        ],
    );
    assert_eq!(
        *a.simd_gt(b),
        [
            -1, 0, 0, -1, -1, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, -1, -1, -1, -1, -1,
            0, -1, 0, -1, 0, -1, 0, -1
        ]
    );
}

#[simd_test]
fn min_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16, 1, -2, 3, -4, 5, -6, 7,
            -8, 9, -10, 11, -12, 13, -14, 15, -16,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15, 2, -1, 4, -3, 6, -5, 8,
            -7, 10, -9, 12, -11, 14, -13, 16, -15,
        ],
    );
    assert_eq!(
        *a.min(b),
        [
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16, 1, -2, 3, -4, 5, -6, 7,
            -8, 9, -10, 11, -12, 13, -14, 15, -16
        ]
    );
}

#[simd_test]
fn max_i8x32<S: Simd>(simd: S) {
    let a = i8x32::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16, 1, -2, 3, -4, 5, -6, 7,
            -8, 9, -10, 11, -12, 13, -14, 15, -16,
        ],
    );
    let b = i8x32::from_slice(
        simd,
        &[
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15, 2, -1, 4, -3, 6, -5, 8,
            -7, 10, -9, 12, -11, 14, -13, 16, -15,
        ],
    );
    assert_eq!(
        *a.max(b),
        [
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15, 2, -1, 4, -3, 6, -5, 8,
            -7, 10, -9, 12, -11, 14, -13, 16, -15
        ]
    );
}

// =============================================================================
// u8x32 tests (256-bit equivalents of u8x16 tests)
// =============================================================================

#[simd_test]
fn and_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            0, 1, 0,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
            85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
        ],
    );
    assert_eq!(
        *(a & b),
        [
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            0, 1, 0
        ]
    );
}

#[simd_test]
fn or_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5,
            6, 7, 8,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
    );
    assert_eq!(
        *(a | b),
        [
            1, 1, 3, 3, 6, 7, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 3, 3, 6, 7, 6, 7, 1, 2, 3, 4, 5,
            6, 7, 8
        ]
    );
}

#[simd_test]
fn xor_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 0,
            0, 0, 0,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            1, 1, 0, 0, 5, 4, 7, 6, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 5, 4, 7, 6, 1, 0, 1, 0, 1,
            0, 1, 0,
        ],
    );
    assert_eq!(
        *(a ^ b),
        [
            1, 0, 2, 3, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 2, 3, 1, 1, 1, 1, 0, 1, 0, 1, 1,
            0, 1, 0
        ]
    );
}

#[simd_test]
fn not_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5,
            6, 7, 8,
        ],
    );
    assert_eq!(
        *(!a),
        [
            255, 254, 253, 252, 251, 250, 249, 248, 254, 253, 252, 251, 250, 249, 248, 247, 255,
            254, 253, 252, 251, 250, 249, 248, 254, 253, 252, 251, 250, 249, 248, 247
        ]
    );
}

#[simd_test]
fn add_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 10, 20, 30, 40,
            50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    assert_eq!(
        *(a + b),
        [
            11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165, 176, 11, 22, 33, 44,
            55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165, 176
        ]
    );
}

#[simd_test]
fn sub_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
            100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16,
        ],
    );
    assert_eq!(
        *(a - b),
        [
            99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 99, 98, 97, 96, 95, 94,
            93, 92, 91, 90, 89, 88, 87, 86, 85, 84
        ]
    );
}

#[simd_test]
fn min_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 10, 20, 30, 40,
            50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            15, 15, 35, 35, 45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165, 15, 15, 35, 35,
            45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165,
        ],
    );
    assert_eq!(
        *a.min(b),
        [
            10, 15, 30, 35, 45, 60, 65, 80, 85, 100, 105, 120, 125, 140, 145, 160, 10, 15, 30, 35,
            45, 60, 65, 80, 85, 100, 105, 120, 125, 140, 145, 160
        ]
    );
}

#[simd_test]
fn max_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 10, 20, 30, 40,
            50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            15, 15, 35, 35, 45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165, 15, 15, 35, 35,
            45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165,
        ],
    );
    assert_eq!(
        *a.max(b),
        [
            15, 20, 35, 40, 50, 65, 70, 85, 90, 105, 110, 125, 130, 145, 150, 165, 15, 20, 35, 40,
            50, 65, 70, 85, 90, 105, 110, 125, 130, 145, 150, 165
        ]
    );
}

#[simd_test]
fn simd_eq_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            1, 0, 3, 0, 5, 0, 7, 0, 9, 0, 11, 0, 13, 0, 15, 0, 1, 0, 3, 0, 5, 0, 7, 0, 9, 0, 11, 0,
            13, 0, 15, 0,
        ],
    );
    assert_eq!(
        *a.simd_eq(b),
        [
            -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
            0, -1, 0, -1, 0, -1, 0
        ]
    );
}

#[simd_test]
fn simd_lt_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 10, 20, 30, 40, 50, 60, 70, 80, 1, 2, 3, 4, 5, 6, 7, 8, 10, 20,
            30, 40, 50, 60, 70, 80,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            2, 2, 2, 5, 4, 7, 6, 9, 5, 25, 25, 45, 45, 65, 65, 85, 2, 2, 2, 5, 4, 7, 6, 9, 5, 25,
            25, 45, 45, 65, 65, 85,
        ],
    );
    assert_eq!(
        *a.simd_lt(b),
        [
            -1, 0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, -1, 0, -1, 0, -1, 0,
            -1, 0, -1, 0, -1, 0, -1
        ]
    );
}

#[simd_test]
fn simd_gt_u8x32<S: Simd>(simd: S) {
    let a = u8x32::from_slice(
        simd,
        &[
            2, 2, 2, 5, 4, 7, 6, 9, 5, 25, 25, 45, 45, 65, 65, 85, 2, 2, 2, 5, 4, 7, 6, 9, 5, 25,
            25, 45, 45, 65, 65, 85,
        ],
    );
    let b = u8x32::from_slice(
        simd,
        &[
            1, 2, 3, 4, 5, 6, 7, 8, 10, 20, 30, 40, 50, 60, 70, 80, 1, 2, 3, 4, 5, 6, 7, 8, 10, 20,
            30, 40, 50, 60, 70, 80,
        ],
    );
    assert_eq!(
        *a.simd_gt(b),
        [
            -1, 0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, -1, 0, -1, 0, -1, 0,
            -1, 0, -1, 0, -1, 0, -1
        ]
    );
}

// =============================================================================
// i16x16 tests (256-bit equivalents of i16x8 tests)
// =============================================================================

#[simd_test]
fn add_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    );
    let b = i16x16::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    assert_eq!(
        *(a + b),
        [
            11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165, 176
        ]
    );
}

#[simd_test]
fn sub_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[
            100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600,
        ],
    );
    let b = i16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    );
    assert_eq!(
        *(a - b),
        [
            99, 198, 297, 396, 495, 594, 693, 792, 891, 990, 1089, 1188, 1287, 1386, 1485, 1584
        ]
    );
}

#[simd_test]
fn neg_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16,
        ],
    );
    assert_eq!(
        *(-a),
        [
            -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14, -15, 16
        ]
    );
}

#[simd_test]
fn simd_eq_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]);
    let b = i16x16::from_slice(simd, &[1, 0, 3, 0, 5, 0, 7, 0, 1, 0, 3, 0, 5, 0, 7, 0]);
    assert_eq!(
        *a.simd_eq(b),
        [-1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0]
    );
}

#[simd_test]
fn simd_lt_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[1, 2, 3, 4, -1, -2, -3, -4, 10, 20, 30, 40, 50, 60, 70, 80],
    );
    let b = i16x16::from_slice(
        simd,
        &[2, 2, 2, 5, 0, 0, 0, 0, 5, 25, 25, 45, 45, 65, 65, 85],
    );
    assert_eq!(
        *a.simd_lt(b),
        [-1, 0, 0, -1, -1, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1]
    );
}

#[simd_test]
fn simd_gt_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[2, 2, 2, 5, 0, 0, 0, 0, 5, 25, 25, 45, 45, 65, 65, 85],
    );
    let b = i16x16::from_slice(
        simd,
        &[1, 2, 3, 4, -1, -2, -3, -4, 10, 20, 30, 40, 50, 60, 70, 80],
    );
    assert_eq!(
        *a.simd_gt(b),
        [-1, 0, 0, -1, -1, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1]
    );
}

#[simd_test]
fn min_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16,
        ],
    );
    let b = i16x16::from_slice(
        simd,
        &[
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15,
        ],
    );
    assert_eq!(
        *a.min(b),
        [
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16
        ]
    );
}

#[simd_test]
fn max_i16x16<S: Simd>(simd: S) {
    let a = i16x16::from_slice(
        simd,
        &[
            1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 11, -12, 13, -14, 15, -16,
        ],
    );
    let b = i16x16::from_slice(
        simd,
        &[
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15,
        ],
    );
    assert_eq!(
        *a.max(b),
        [
            2, -1, 4, -3, 6, -5, 8, -7, 10, -9, 12, -11, 14, -13, 16, -15
        ]
    );
}

// =============================================================================
// u16x16 tests (256-bit equivalents of u16x8 tests)
// =============================================================================

#[simd_test]
fn add_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    );
    let b = u16x16::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    assert_eq!(
        *(a + b),
        [
            11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165, 176
        ]
    );
}

#[simd_test]
fn sub_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[
            100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600,
        ],
    );
    let b = u16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    );
    assert_eq!(
        *(a - b),
        [
            99, 198, 297, 396, 495, 594, 693, 792, 891, 990, 1089, 1188, 1287, 1386, 1485, 1584
        ]
    );
}

#[simd_test]
fn simd_eq_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]);
    let b = u16x16::from_slice(simd, &[1, 0, 3, 0, 5, 0, 7, 0, 1, 0, 3, 0, 5, 0, 7, 0]);
    assert_eq!(
        *a.simd_eq(b),
        [-1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0]
    );
}

#[simd_test]
fn simd_lt_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 10, 20, 30, 40, 50, 60, 70, 80],
    );
    let b = u16x16::from_slice(
        simd,
        &[2, 2, 2, 5, 4, 7, 6, 9, 5, 25, 25, 45, 45, 65, 65, 85],
    );
    assert_eq!(
        *a.simd_lt(b),
        [-1, 0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1]
    );
}

#[simd_test]
fn simd_gt_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[2, 2, 2, 5, 4, 7, 6, 9, 5, 25, 25, 45, 45, 65, 65, 85],
    );
    let b = u16x16::from_slice(
        simd,
        &[1, 2, 3, 4, 5, 6, 7, 8, 10, 20, 30, 40, 50, 60, 70, 80],
    );
    assert_eq!(
        *a.simd_gt(b),
        [-1, 0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1]
    );
}

#[simd_test]
fn min_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    let b = u16x16::from_slice(
        simd,
        &[
            15, 15, 35, 35, 45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165,
        ],
    );
    assert_eq!(
        *a.min(b),
        [
            10, 15, 30, 35, 45, 60, 65, 80, 85, 100, 105, 120, 125, 140, 145, 160
        ]
    );
}

#[simd_test]
fn max_u16x16<S: Simd>(simd: S) {
    let a = u16x16::from_slice(
        simd,
        &[
            10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        ],
    );
    let b = u16x16::from_slice(
        simd,
        &[
            15, 15, 35, 35, 45, 65, 65, 85, 85, 105, 105, 125, 125, 145, 145, 165,
        ],
    );
    assert_eq!(
        *a.max(b),
        [
            15, 20, 35, 40, 50, 65, 70, 85, 90, 105, 110, 125, 130, 145, 150, 165
        ]
    );
}

// =============================================================================
// i32x8 tests (256-bit equivalents of i32x4 tests)
// =============================================================================

#[simd_test]
fn add_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = i32x8::from_slice(simd, &[10, 20, 30, 40, 50, 60, 70, 80]);
    assert_eq!(*(a + b), [11, 22, 33, 44, 55, 66, 77, 88]);
}

#[simd_test]
fn sub_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[100, 200, 300, 400, 500, 600, 700, 800]);
    let b = i32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    assert_eq!(*(a - b), [99, 198, 297, 396, 495, 594, 693, 792]);
}

#[simd_test]
fn neg_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, -2, 3, -4, 5, -6, 7, -8]);
    assert_eq!(*(-a), [-1, 2, -3, 4, -5, 6, -7, 8]);
}

#[simd_test]
fn simd_eq_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = i32x8::from_slice(simd, &[1, 0, 3, 0, 5, 0, 7, 0]);
    assert_eq!(*a.simd_eq(b), [-1, 0, -1, 0, -1, 0, -1, 0]);
}

#[simd_test]
fn simd_lt_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, 2, 3, 4, -1, -2, -3, -4]);
    let b = i32x8::from_slice(simd, &[2, 2, 2, 5, 0, 0, 0, 0]);
    assert_eq!(*a.simd_lt(b), [-1, 0, 0, -1, -1, -1, -1, -1]);
}

#[simd_test]
fn simd_gt_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[2, 2, 2, 5, 0, 0, 0, 0]);
    let b = i32x8::from_slice(simd, &[1, 2, 3, 4, -1, -2, -3, -4]);
    assert_eq!(*a.simd_gt(b), [-1, 0, 0, -1, -1, -1, -1, -1]);
}

#[simd_test]
fn min_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, -2, 3, -4, 5, -6, 7, -8]);
    let b = i32x8::from_slice(simd, &[2, -1, 4, -3, 6, -5, 8, -7]);
    assert_eq!(*a.min(b), [1, -2, 3, -4, 5, -6, 7, -8]);
}

#[simd_test]
fn max_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, -2, 3, -4, 5, -6, 7, -8]);
    let b = i32x8::from_slice(simd, &[2, -1, 4, -3, 6, -5, 8, -7]);
    assert_eq!(*a.max(b), [2, -1, 4, -3, 6, -5, 8, -7]);
}

#[simd_test]
fn mul_i32x8<S: Simd>(simd: S) {
    let a = i32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = i32x8::from_slice(simd, &[2, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(*(a * b), [2, 6, 12, 20, 30, 42, 56, 72]);
}

// =============================================================================
// u32x8 tests (256-bit equivalents of u32x4 tests)
// =============================================================================

#[simd_test]
fn add_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = u32x8::from_slice(simd, &[10, 20, 30, 40, 50, 60, 70, 80]);
    assert_eq!(*(a + b), [11, 22, 33, 44, 55, 66, 77, 88]);
}

#[simd_test]
fn sub_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[100, 200, 300, 400, 500, 600, 700, 800]);
    let b = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    assert_eq!(*(a - b), [99, 198, 297, 396, 495, 594, 693, 792]);
}

#[simd_test]
fn simd_eq_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = u32x8::from_slice(simd, &[1, 0, 3, 0, 5, 0, 7, 0]);
    assert_eq!(*a.simd_eq(b), [-1, 0, -1, 0, -1, 0, -1, 0]);
}

#[simd_test]
fn simd_lt_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = u32x8::from_slice(simd, &[2, 2, 2, 5, 4, 7, 6, 9]);
    assert_eq!(*a.simd_lt(b), [-1, 0, 0, -1, 0, -1, 0, -1]);
}

#[simd_test]
fn simd_gt_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[2, 2, 2, 5, 4, 7, 6, 9]);
    let b = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    assert_eq!(*a.simd_gt(b), [-1, 0, 0, -1, 0, -1, 0, -1]);
}

#[simd_test]
fn min_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[10, 20, 30, 40, 50, 60, 70, 80]);
    let b = u32x8::from_slice(simd, &[15, 15, 35, 35, 45, 65, 65, 85]);
    assert_eq!(*a.min(b), [10, 15, 30, 35, 45, 60, 65, 80]);
}

#[simd_test]
fn max_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[10, 20, 30, 40, 50, 60, 70, 80]);
    let b = u32x8::from_slice(simd, &[15, 15, 35, 35, 45, 65, 65, 85]);
    assert_eq!(*a.max(b), [15, 20, 35, 40, 50, 65, 70, 85]);
}

#[simd_test]
fn mul_u32x8<S: Simd>(simd: S) {
    let a = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);
    let b = u32x8::from_slice(simd, &[2, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(*(a * b), [2, 6, 12, 20, 30, 42, 56, 72]);
}
