mod data;

use std::fmt::Write;
use std::fs;
use std::{
    cell::RefCell,
    collections::HashMap,
    fs::create_dir_all,
    io,
    path::{Path, PathBuf},
};

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let src_dir = manifest_dir.ancestors().nth(1).unwrap().join("src");
    generate_for_arch(&src_dir, "x86", data::X86_TEMPLATE, data::X86_FEATURES).unwrap();
}

fn generate_for_arch(
    root_dir: &Path,
    arch_module_name: &str,
    template: &str,
    features: &'static [Feature],
) -> io::Result<()> {
    let arch_dir = root_dir.join(arch_module_name);
    let features = normalize_features(features);
    for feature in &features {
        let mut new_docs = String::new();
        for line in feature.feature.extra_docs.lines() {
            writeln!(&mut new_docs, "///{line}").unwrap();
        }
        let enabled_feature_str_list = format!(
            r#""{}", {}"#,
            feature.feature.feature_name,
            feature
                .children
                .iter()
                .map(|it| format!(r#""{it}""#))
                .collect::<Vec<_>>()
                .join(", ")
        );
        let mut from_impls = String::new();
        for child in &feature.children {
            let from_feature = features
                .iter()
                .find(|it| it.feature.feature_name == *child)
                .unwrap();
            let type_path = format!(
                "crate::{arch_module_name}::{}::{}",
                from_feature.feature.module, from_feature.feature.struct_name
            );
            write!(
                from_impls,
                "\n\
impl From<FEATURE_STRUCT_NAME> for {type_path} {{
    fn from(value: FEATURE_STRUCT_NAME) -> Self {{
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([FEATURE_STRUCT_NAME = value] => \"{{FEATURE_ID}}\", fn() -> {type_path} {{ {type_path}::new() }})
    }}
}}\n"
            ).unwrap();
        }
        let mut result = format!(
            "// This file is automatically generated by `fearless_simd_core_gen`.\n\
            // Its template can be found in `fearless_simd_core/gen/templates`.\n\n\
            {template}"
        );
        // We replace the from impls first, as they use template variables from the rest of this.
        result = result.replace("/*{FROM_IMPLS}*/", &from_impls);
        result = result.replace("{FEATURE_DOCS_NAME}", feature.feature.feature_docs_name);
        result = result.replace("/// {NEW_DOCS}\n", &new_docs);
        result = result.replace("{FEATURE_ID}", feature.feature.feature_name);
        result = result.replace(
            "{EXAMPLE_FUNCTION_NAME}",
            feature.feature.example_function_name,
        );
        result = result.replace("FEATURE_STRUCT_NAME", feature.feature.struct_name);
        result = result.replace(
            r#""{ENABLED_FEATURES_STR_LIST}""#,
            &enabled_feature_str_list,
        );
        let module_dir = arch_dir.join(feature.feature.module);
        create_dir_all(&module_dir)?;
        let mut file = module_dir.join(feature.feature.feature_name.replace(".", "_"));
        file.set_extension("rs");
        fs::write(file, result)?;
    }
    Ok(())
}

#[derive(Debug)]
struct Feature {
    /// The name of the struct to be generated.
    struct_name: &'static str,
    /// The Rust name for the feature, e.g. `"sse"`.
    feature_name: &'static str,
    /// The array of features which are implicitly enabled by this feature.
    /// Note that this array does not include transitive enabled features.
    directly_implicitly_enabled: &'static [&'static str],
    /// Any additional docs which we want to add to the module.
    extra_docs: &'static str,
    /// The name of the function used in the examples.
    /// Ideally, we'd make this optional, but that starts making the templating look more complicated.
    example_function_name: &'static str,
    /// The "display name" for the feature, used inside the docs.
    feature_docs_name: &'static str,
    /// Extra code added at the end.
    /// Used for implicitly enabled features.
    additional_impls: &'static str,
    /// The module (if any) this feature will belong to.
    ///
    /// (Note that imports into the module are checked to exist, but not automatically inserted).
    module: &'static str,
}

/// Implementation detail intermediate struct of `normalize_features`.
struct MaybeNormalizedFeature {
    /// The actual feature.
    feature: &'static Feature,
    /// The fully deduplicated, sorted list of target features enabled by this feature, including with all
    /// implicitly enabled features resolved.
    ///
    /// Note that this *excludes* the parent target feature.
    // We use a RefCell here as we know there cannot be loops.
    children: RefCell<Option<Vec<&'static str>>>,
}

#[derive(Debug)]
struct NormalizedFeature {
    feature: &'static Feature,
    children: Vec<&'static str>,
}

fn normalize_features(features: &'static [Feature]) -> Vec<NormalizedFeature> {
    let mut state = HashMap::new();
    for feature in features {
        state.insert(
            feature.feature_name,
            MaybeNormalizedFeature {
                feature,
                children: RefCell::new(None),
            },
        );
    }
    fn handle_item(state: &HashMap<&str, MaybeNormalizedFeature>, item: &MaybeNormalizedFeature) {
        // We borrow for the entire lifetime to avoid infinite loops.
        let mut borrowed_children = item.children.borrow_mut();
        if borrowed_children.is_some() {
            return;
        }
        let mut new_children = Vec::new();
        for child in item.feature.directly_implicitly_enabled {
            new_children.push(*child);
            let child = state
                .get(child)
                .expect("Every implicitly enabled feature should exist.");
            handle_item(state, child);
            new_children.extend_from_slice(child.children.borrow().as_ref().unwrap());
        }
        new_children.sort();
        new_children.dedup();
        *borrowed_children = Some(new_children);
    }
    for feature in state.values() {
        handle_item(&state, feature);
    }
    let mut output = Vec::new();
    for (_, feature) in state {
        output.push(NormalizedFeature {
            feature: feature.feature,
            children: feature.children.into_inner().unwrap(),
        });
    }
    output.sort_by_key(|it| it.feature.feature_name);
    output
}
