// Copyright 2025 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

// This file is automatically generated by `fearless_simd_core_gen`.
// Its template can be found in `fearless_simd_core/gen/templates`.
//! The AVX512-VP2INTERSECT target feature.

use crate::{TargetFeatureToken, trampoline};

use core::fmt::Debug;

/// [AVX512-VP2INTERSECT] --- Advanced Vector Extensions 512-bit - Vector Pair Intersection to a Pair of Mask Registers
///
/// [AVX512-VP2INTERSECT]: https://en.wikipedia.org/wiki/AVX-512#VP2INTERSECT
///
/// A token indicating that the current CPU has the `avx512vp2intersect` target feature.
///
/// # Example
///
/// This can be used to [`trampoline!`] into functions like:
///
/// ```rust
/// #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
/// #[target_feature(enable = "avx512vp2intersect")]
/// fn uses_avx512vp2intersect() {
///     // ...
/// }
/// ```
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct Avx512vp2intersect {
    // We don't use non_exhaustive because we don't want this struct to be constructible.
    // in different modules in this crate.
    _private: (),
}

impl Debug for Avx512vp2intersect {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, r#""avx512vp2intersect" enabled."#)
    }
}

// Safety: This token can only be constructed if you have proof that all the requisite
// target feature is enabled.
unsafe impl TargetFeatureToken for Avx512vp2intersect {
    const FEATURES: &[&str] = &[
        "avx512vp2intersect",
        "avx",
        "avx2",
        "avx512f",
        "f16c",
        "fma",
        "sse",
        "sse2",
        "sse3",
        "sse4.1",
        "sse4.2",
        "ssse3",
    ];

    #[inline(always)]
    fn vectorize<R>(self, f: impl FnOnce() -> R) -> R {
        // Because we need the safety check to be eagerly evaluated, it uses an constant item.
        // This means we can't use `Self = self` here, unfortunately.
        trampoline!([Avx512vp2intersect = self] => "avx512vp2intersect", <(R)> fn<(R)>(f: impl FnOnce() -> R = f) -> R { f() })
    }
}

impl Avx512vp2intersect {
    #[cfg(feature = "std")]
    /// Create a new token if the `"avx512vp2intersect"` target feature is detected as enabled.
    ///
    /// This does not do any caching internally, although note that the standard
    /// library does internally cache the features it detects.
    // TODO: Consider a manual override feature/env var?
    pub fn try_new() -> Option<Self> {
        // Feature flag required to make docs compile.
        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
        if std::arch::is_x86_feature_detected!("avx512vp2intersect") {
            // Safety: The required CPU feature was detected.
            unsafe { Some(Self::new()) }
        } else {
            None
        }
    }

    #[target_feature(enable = "avx512vp2intersect")]
    /// Create a new token for the "avx512vp2intersect" target feature.
    ///
    /// This method is useful to get a new token if you have an external proof that
    /// AVX512-VP2INTERSECT is available. This could happen if you are in a target feature
    /// function called by an external library user.
    ///
    /// # Safety
    ///
    /// No conditions other than those inherited from the target feature attribute,
    /// i.e. that the "avx512vp2intersect" target feature is available.
    ///
    /// [implicitly enables]: https://doc.rust-lang.org/beta/reference/attributes/codegen.html?highlight=implicitly%20enabled#r-attributes.codegen.target_feature.safety-restrictions
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl From<Avx512vp2intersect> for crate::x86::avx::Avx {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::avx::Avx { crate::x86::avx::Avx::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::avx::Avx2 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::avx::Avx2 { crate::x86::avx::Avx2::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::avx512::Avx512f {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::avx512::Avx512f { crate::x86::avx512::Avx512f::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::v3::F16c {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::v3::F16c { crate::x86::v3::F16c::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::v3::Fma {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::v3::Fma { crate::x86::v3::Fma::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::Sse {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::Sse { crate::x86::sse::Sse::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::Sse2 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::Sse2 { crate::x86::sse::Sse2::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::Sse3 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::Sse3 { crate::x86::sse::Sse3::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::Sse4_1 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::Sse4_1 { crate::x86::sse::Sse4_1::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::Sse4_2 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::Sse4_2 { crate::x86::sse::Sse4_2::new() })
    }
}

impl From<Avx512vp2intersect> for crate::x86::sse::SupplementalSse3 {
    fn from(value: Avx512vp2intersect) -> Self {
        // This also serves as a correctness check of the implicitly enabled features.
        trampoline!([Avx512vp2intersect = value] => "avx512vp2intersect", fn() -> crate::x86::sse::SupplementalSse3 { crate::x86::sse::SupplementalSse3::new() })
    }
}

const _: () = {
    assert!(
        core::mem::size_of::<Avx512vp2intersect>() == 0,
        "Target feature tokens should be zero sized."
    );
};
