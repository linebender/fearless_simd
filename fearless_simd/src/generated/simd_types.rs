// Copyright 2026 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

// This file is autogenerated by fearless_simd_gen

use crate::{Bytes, Select, Simd, SimdBase, SimdCvtFloat, SimdCvtTruncate, SimdFrom, SimdInto};
#[doc = "A SIMD vector of 4 [`f32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f32x4};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f32x4::splat(simd, 1.0);\n    let b = f32x4::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f32x4::from_slice(simd, &[1.0, 2.0, 3.0, 4.0]);\n\n    // From an array:\n    let d = f32x4::simd_from(simd, [1.0, 2.0, 3.0, 4.0]);\n\n    // From an element-wise function:\n    let e = f32x4::from_fn(simd, |i| i as f32);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct f32x4<S: Simd> {
    pub(crate) val: S::f32x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f32; 4], S> for f32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f32; 4]) -> Self {
        simd.load_array_f32x4(val)
    }
}
impl<S: Simd> From<f32x4<S>> for [f32; 4] {
    #[inline(always)]
    fn from(value: f32x4<S>) -> Self {
        value.simd.as_array_f32x4(value)
    }
}
impl<S: Simd> core::ops::Deref for f32x4<S> {
    type Target = [f32; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f32x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f32x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f32x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f32x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "f32x4", &self.simd, self.simd.as_array_ref_f32x4(self))
    }
}
impl<S: Simd> SimdFrom<f32, S> for f32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f32) -> Self {
        simd.splat_f32x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f32x4<S> {
    type Output = f32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f32x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f32x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f32x4(self)[i]
    }
}
impl<S: Simd> Select<f32x4<S>> for mask32x4<S> {
    #[inline(always)]
    fn select(self, if_true: f32x4<S>, if_false: f32x4<S>) -> f32x4<S> {
        self.simd.select_f32x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f32x4<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f32x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f32x4(value)
    }
}
impl<S: Simd> SimdBase<S> for f32x4<S> {
    type Element = f32;
    const N: usize = 4;
    type Mask = mask32x4<S>;
    type Block = f32x4<S>;
    type Array = [f32; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f32] {
        self.simd.as_array_ref_f32x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f32] {
        self.simd.as_array_mut_f32x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f32]) -> Self {
        simd.load_array_ref_f32x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f32]) {
        self.simd
            .store_array_f32x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f32) -> Self {
        simd.splat_f32x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f32) -> Self {
        simd.load_array_f32x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f32x4<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f32x4(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f32x4(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f32x4(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f32x4(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f32x4(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f32x4(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f32x4(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f32x4(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f32x4(self)
    }
}
impl<S: Simd> SimdCvtFloat<u32x4<S>> for f32x4<S> {
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: u32x4<S>) -> Self {
        x.simd.cvt_f32_u32x4(x)
    }
}
impl<S: Simd> SimdCvtFloat<i32x4<S>> for f32x4<S> {
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: i32x4<S>) -> Self {
        x.simd.cvt_f32_i32x4(x)
    }
}
impl<S: Simd> crate::SimdCombine<S> for f32x4<S> {
    type Combined = f32x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_f32x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 16 [`i8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i8x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i8x16::splat(simd, 1);\n    let b = i8x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i8x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = i8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = i8x16::from_fn(simd, |i| i as i8);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct i8x16<S: Simd> {
    pub(crate) val: S::i8x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 16], S> for i8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 16]) -> Self {
        simd.load_array_i8x16(val)
    }
}
impl<S: Simd> From<i8x16<S>> for [i8; 16] {
    #[inline(always)]
    fn from(value: i8x16<S>) -> Self {
        value.simd.as_array_i8x16(value)
    }
}
impl<S: Simd> core::ops::Deref for i8x16<S> {
    type Target = [i8; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i8x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i8x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i8x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i8x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i8x16", &self.simd, self.simd.as_array_ref_i8x16(self))
    }
}
impl<S: Simd> SimdFrom<i8, S> for i8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_i8x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i8x16<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i8x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i8x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i8x16(self)[i]
    }
}
impl<S: Simd> Select<i8x16<S>> for mask8x16<S> {
    #[inline(always)]
    fn select(self, if_true: i8x16<S>, if_false: i8x16<S>) -> i8x16<S> {
        self.simd.select_i8x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i8x16<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i8x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i8x16(value)
    }
}
impl<S: Simd> SimdBase<S> for i8x16<S> {
    type Element = i8;
    const N: usize = 16;
    type Mask = mask8x16<S>;
    type Block = i8x16<S>;
    type Array = [i8; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_i8x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_i8x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_i8x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_i8x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_i8x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_i8x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i8x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i8x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdCombine<S> for i8x16<S> {
    type Combined = i8x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i8x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 16 [`u8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u8x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u8x16::splat(simd, 1);\n    let b = u8x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u8x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = u8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = u8x16::from_fn(simd, |i| i as u8);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct u8x16<S: Simd> {
    pub(crate) val: S::u8x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u8; 16], S> for u8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u8; 16]) -> Self {
        simd.load_array_u8x16(val)
    }
}
impl<S: Simd> From<u8x16<S>> for [u8; 16] {
    #[inline(always)]
    fn from(value: u8x16<S>) -> Self {
        value.simd.as_array_u8x16(value)
    }
}
impl<S: Simd> core::ops::Deref for u8x16<S> {
    type Target = [u8; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u8x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u8x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u8x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u8x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u8x16", &self.simd, self.simd.as_array_ref_u8x16(self))
    }
}
impl<S: Simd> SimdFrom<u8, S> for u8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u8) -> Self {
        simd.splat_u8x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u8x16<S> {
    type Output = u8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u8x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u8x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u8x16(self)[i]
    }
}
impl<S: Simd> Select<u8x16<S>> for mask8x16<S> {
    #[inline(always)]
    fn select(self, if_true: u8x16<S>, if_false: u8x16<S>) -> u8x16<S> {
        self.simd.select_u8x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u8x16<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u8x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u8x16(value)
    }
}
impl<S: Simd> SimdBase<S> for u8x16<S> {
    type Element = u8;
    const N: usize = 16;
    type Mask = mask8x16<S>;
    type Block = u8x16<S>;
    type Array = [u8; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u8] {
        self.simd.as_array_ref_u8x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u8] {
        self.simd.as_array_mut_u8x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u8]) -> Self {
        simd.load_array_ref_u8x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u8]) {
        self.simd
            .store_array_u8x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u8) -> Self {
        simd.splat_u8x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u8) -> Self {
        simd.load_array_u8x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u8x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u8x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdCombine<S> for u8x16<S> {
    type Combined = u8x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u8x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 16 8-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct mask8x16<S: Simd> {
    pub(crate) val: S::mask8x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 16], S> for mask8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 16]) -> Self {
        simd.load_array_mask8x16(val)
    }
}
impl<S: Simd> From<mask8x16<S>> for [i8; 16] {
    #[inline(always)]
    fn from(value: mask8x16<S>) -> Self {
        value.simd.as_array_mask8x16(value)
    }
}
impl<S: Simd> core::ops::Deref for mask8x16<S> {
    type Target = [i8; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask8x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask8x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask8x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask8x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask8x16",
            &self.simd,
            self.simd.as_array_ref_mask8x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<i8, S> for mask8x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_mask8x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask8x16<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask8x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask8x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask8x16(self)[i]
    }
}
impl<S: Simd> Select<mask8x16<S>> for mask8x16<S> {
    #[inline(always)]
    fn select(self, if_true: mask8x16<S>, if_false: mask8x16<S>) -> mask8x16<S> {
        self.simd.select_mask8x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask8x16<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask8x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask8x16(value)
    }
}
impl<S: Simd> SimdBase<S> for mask8x16<S> {
    type Element = i8;
    const N: usize = 16;
    type Mask = mask8x16<S>;
    type Block = mask8x16<S>;
    type Array = [i8; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_mask8x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_mask8x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_mask8x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_mask8x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_mask8x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_mask8x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask8x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask8x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask8x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask8x16(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask8x16(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask8x16(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask8x16(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask8x16<S> {
    type Combined = mask8x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask8x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 8 [`i16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i16x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i16x8::splat(simd, 1);\n    let b = i16x8::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i16x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an array:\n    let d = i16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an element-wise function:\n    let e = i16x8::from_fn(simd, |i| i as i16);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct i16x8<S: Simd> {
    pub(crate) val: S::i16x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 8], S> for i16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 8]) -> Self {
        simd.load_array_i16x8(val)
    }
}
impl<S: Simd> From<i16x8<S>> for [i16; 8] {
    #[inline(always)]
    fn from(value: i16x8<S>) -> Self {
        value.simd.as_array_i16x8(value)
    }
}
impl<S: Simd> core::ops::Deref for i16x8<S> {
    type Target = [i16; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i16x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i16x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i16x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i16x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i16x8", &self.simd, self.simd.as_array_ref_i16x8(self))
    }
}
impl<S: Simd> SimdFrom<i16, S> for i16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_i16x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i16x8<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i16x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i16x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i16x8(self)[i]
    }
}
impl<S: Simd> Select<i16x8<S>> for mask16x8<S> {
    #[inline(always)]
    fn select(self, if_true: i16x8<S>, if_false: i16x8<S>) -> i16x8<S> {
        self.simd.select_i16x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i16x8<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i16x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i16x8(value)
    }
}
impl<S: Simd> SimdBase<S> for i16x8<S> {
    type Element = i16;
    const N: usize = 8;
    type Mask = mask16x8<S>;
    type Block = i16x8<S>;
    type Array = [i16; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_i16x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_i16x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_i16x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_i16x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_i16x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_i16x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i16x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i16x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdCombine<S> for i16x8<S> {
    type Combined = i16x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i16x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 8 [`u16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u16x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u16x8::splat(simd, 1);\n    let b = u16x8::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u16x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an array:\n    let d = u16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an element-wise function:\n    let e = u16x8::from_fn(simd, |i| i as u16);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct u16x8<S: Simd> {
    pub(crate) val: S::u16x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u16; 8], S> for u16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u16; 8]) -> Self {
        simd.load_array_u16x8(val)
    }
}
impl<S: Simd> From<u16x8<S>> for [u16; 8] {
    #[inline(always)]
    fn from(value: u16x8<S>) -> Self {
        value.simd.as_array_u16x8(value)
    }
}
impl<S: Simd> core::ops::Deref for u16x8<S> {
    type Target = [u16; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u16x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u16x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u16x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u16x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u16x8", &self.simd, self.simd.as_array_ref_u16x8(self))
    }
}
impl<S: Simd> SimdFrom<u16, S> for u16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u16) -> Self {
        simd.splat_u16x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u16x8<S> {
    type Output = u16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u16x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u16x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u16x8(self)[i]
    }
}
impl<S: Simd> Select<u16x8<S>> for mask16x8<S> {
    #[inline(always)]
    fn select(self, if_true: u16x8<S>, if_false: u16x8<S>) -> u16x8<S> {
        self.simd.select_u16x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u16x8<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u16x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u16x8(value)
    }
}
impl<S: Simd> SimdBase<S> for u16x8<S> {
    type Element = u16;
    const N: usize = 8;
    type Mask = mask16x8<S>;
    type Block = u16x8<S>;
    type Array = [u16; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u16] {
        self.simd.as_array_ref_u16x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u16] {
        self.simd.as_array_mut_u16x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u16]) -> Self {
        simd.load_array_ref_u16x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u16]) {
        self.simd
            .store_array_u16x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u16) -> Self {
        simd.splat_u16x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u16) -> Self {
        simd.load_array_u16x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u16x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u16x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdCombine<S> for u16x8<S> {
    type Combined = u16x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u16x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 8 16-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct mask16x8<S: Simd> {
    pub(crate) val: S::mask16x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 8], S> for mask16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 8]) -> Self {
        simd.load_array_mask16x8(val)
    }
}
impl<S: Simd> From<mask16x8<S>> for [i16; 8] {
    #[inline(always)]
    fn from(value: mask16x8<S>) -> Self {
        value.simd.as_array_mask16x8(value)
    }
}
impl<S: Simd> core::ops::Deref for mask16x8<S> {
    type Target = [i16; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask16x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask16x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask16x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask16x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask16x8",
            &self.simd,
            self.simd.as_array_ref_mask16x8(self),
        )
    }
}
impl<S: Simd> SimdFrom<i16, S> for mask16x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_mask16x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask16x8<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask16x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask16x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask16x8(self)[i]
    }
}
impl<S: Simd> Select<mask16x8<S>> for mask16x8<S> {
    #[inline(always)]
    fn select(self, if_true: mask16x8<S>, if_false: mask16x8<S>) -> mask16x8<S> {
        self.simd.select_mask16x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask16x8<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask16x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask16x8(value)
    }
}
impl<S: Simd> SimdBase<S> for mask16x8<S> {
    type Element = i16;
    const N: usize = 8;
    type Mask = mask16x8<S>;
    type Block = mask16x8<S>;
    type Array = [i16; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_mask16x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_mask16x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_mask16x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_mask16x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_mask16x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_mask16x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask16x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask16x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask16x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask16x8(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask16x8(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask16x8(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask16x8(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask16x8<S> {
    type Combined = mask16x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask16x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 4 [`i32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i32x4};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i32x4::splat(simd, 1);\n    let b = i32x4::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i32x4::from_slice(simd, &[1, 2, 3, 4]);\n\n    // From an array:\n    let d = i32x4::simd_from(simd, [1, 2, 3, 4]);\n\n    // From an element-wise function:\n    let e = i32x4::from_fn(simd, |i| i as i32);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct i32x4<S: Simd> {
    pub(crate) val: S::i32x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 4], S> for i32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 4]) -> Self {
        simd.load_array_i32x4(val)
    }
}
impl<S: Simd> From<i32x4<S>> for [i32; 4] {
    #[inline(always)]
    fn from(value: i32x4<S>) -> Self {
        value.simd.as_array_i32x4(value)
    }
}
impl<S: Simd> core::ops::Deref for i32x4<S> {
    type Target = [i32; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i32x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i32x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i32x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i32x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i32x4", &self.simd, self.simd.as_array_ref_i32x4(self))
    }
}
impl<S: Simd> SimdFrom<i32, S> for i32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_i32x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i32x4<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i32x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i32x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i32x4(self)[i]
    }
}
impl<S: Simd> Select<i32x4<S>> for mask32x4<S> {
    #[inline(always)]
    fn select(self, if_true: i32x4<S>, if_false: i32x4<S>) -> i32x4<S> {
        self.simd.select_i32x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i32x4<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i32x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i32x4(value)
    }
}
impl<S: Simd> SimdBase<S> for i32x4<S> {
    type Element = i32;
    const N: usize = 4;
    type Mask = mask32x4<S>;
    type Block = i32x4<S>;
    type Array = [i32; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_i32x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_i32x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_i32x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_i32x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_i32x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_i32x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i32x4<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x4<S>> for i32x4<S> {
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    #[inline(always)]
    fn truncate_from(x: f32x4<S>) -> Self {
        x.simd.cvt_i32_f32x4(x)
    }
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x4<S>) -> Self {
        x.simd.cvt_i32_precise_f32x4(x)
    }
}
impl<S: Simd> crate::SimdCombine<S> for i32x4<S> {
    type Combined = i32x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i32x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 4 [`u32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u32x4};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u32x4::splat(simd, 1);\n    let b = u32x4::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u32x4::from_slice(simd, &[1, 2, 3, 4]);\n\n    // From an array:\n    let d = u32x4::simd_from(simd, [1, 2, 3, 4]);\n\n    // From an element-wise function:\n    let e = u32x4::from_fn(simd, |i| i as u32);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct u32x4<S: Simd> {
    pub(crate) val: S::u32x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u32; 4], S> for u32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u32; 4]) -> Self {
        simd.load_array_u32x4(val)
    }
}
impl<S: Simd> From<u32x4<S>> for [u32; 4] {
    #[inline(always)]
    fn from(value: u32x4<S>) -> Self {
        value.simd.as_array_u32x4(value)
    }
}
impl<S: Simd> core::ops::Deref for u32x4<S> {
    type Target = [u32; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u32x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u32x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u32x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u32x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u32x4", &self.simd, self.simd.as_array_ref_u32x4(self))
    }
}
impl<S: Simd> SimdFrom<u32, S> for u32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u32) -> Self {
        simd.splat_u32x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u32x4<S> {
    type Output = u32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u32x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u32x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u32x4(self)[i]
    }
}
impl<S: Simd> Select<u32x4<S>> for mask32x4<S> {
    #[inline(always)]
    fn select(self, if_true: u32x4<S>, if_false: u32x4<S>) -> u32x4<S> {
        self.simd.select_u32x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u32x4<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u32x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u32x4(value)
    }
}
impl<S: Simd> SimdBase<S> for u32x4<S> {
    type Element = u32;
    const N: usize = 4;
    type Mask = mask32x4<S>;
    type Block = u32x4<S>;
    type Array = [u32; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u32] {
        self.simd.as_array_ref_u32x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u32] {
        self.simd.as_array_mut_u32x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u32]) -> Self {
        simd.load_array_ref_u32x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u32]) {
        self.simd
            .store_array_u32x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u32) -> Self {
        simd.splat_u32x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u32) -> Self {
        simd.load_array_u32x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u32x4<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x4<S>> for u32x4<S> {
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    #[inline(always)]
    fn truncate_from(x: f32x4<S>) -> Self {
        x.simd.cvt_u32_f32x4(x)
    }
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x4<S>) -> Self {
        x.simd.cvt_u32_precise_f32x4(x)
    }
}
impl<S: Simd> crate::SimdCombine<S> for u32x4<S> {
    type Combined = u32x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u32x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 4 32-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct mask32x4<S: Simd> {
    pub(crate) val: S::mask32x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 4], S> for mask32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 4]) -> Self {
        simd.load_array_mask32x4(val)
    }
}
impl<S: Simd> From<mask32x4<S>> for [i32; 4] {
    #[inline(always)]
    fn from(value: mask32x4<S>) -> Self {
        value.simd.as_array_mask32x4(value)
    }
}
impl<S: Simd> core::ops::Deref for mask32x4<S> {
    type Target = [i32; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask32x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask32x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask32x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask32x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask32x4",
            &self.simd,
            self.simd.as_array_ref_mask32x4(self),
        )
    }
}
impl<S: Simd> SimdFrom<i32, S> for mask32x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_mask32x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask32x4<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask32x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask32x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask32x4(self)[i]
    }
}
impl<S: Simd> Select<mask32x4<S>> for mask32x4<S> {
    #[inline(always)]
    fn select(self, if_true: mask32x4<S>, if_false: mask32x4<S>) -> mask32x4<S> {
        self.simd.select_mask32x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask32x4<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask32x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask32x4(value)
    }
}
impl<S: Simd> SimdBase<S> for mask32x4<S> {
    type Element = i32;
    const N: usize = 4;
    type Mask = mask32x4<S>;
    type Block = mask32x4<S>;
    type Array = [i32; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_mask32x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_mask32x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_mask32x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_mask32x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_mask32x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_mask32x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask32x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask32x4<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask32x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask32x4(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask32x4(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask32x4(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask32x4(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask32x4<S> {
    type Combined = mask32x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask32x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 2 [`f64`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f64x2};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f64x2::splat(simd, 1.0);\n    let b = f64x2::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f64x2::from_slice(simd, &[1.0, 2.0]);\n\n    // From an array:\n    let d = f64x2::simd_from(simd, [1.0, 2.0]);\n\n    // From an element-wise function:\n    let e = f64x2::from_fn(simd, |i| i as f64);\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct f64x2<S: Simd> {
    pub(crate) val: S::f64x2,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f64; 2], S> for f64x2<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f64; 2]) -> Self {
        simd.load_array_f64x2(val)
    }
}
impl<S: Simd> From<f64x2<S>> for [f64; 2] {
    #[inline(always)]
    fn from(value: f64x2<S>) -> Self {
        value.simd.as_array_f64x2(value)
    }
}
impl<S: Simd> core::ops::Deref for f64x2<S> {
    type Target = [f64; 2];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f64x2(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f64x2<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f64x2(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f64x2<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "f64x2", &self.simd, self.simd.as_array_ref_f64x2(self))
    }
}
impl<S: Simd> SimdFrom<f64, S> for f64x2<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f64) -> Self {
        simd.splat_f64x2(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f64x2<S> {
    type Output = f64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f64x2(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f64x2<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f64x2(self)[i]
    }
}
impl<S: Simd> Select<f64x2<S>> for mask64x2<S> {
    #[inline(always)]
    fn select(self, if_true: f64x2<S>, if_false: f64x2<S>) -> f64x2<S> {
        self.simd.select_f64x2(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f64x2<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f64x2(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f64x2(value)
    }
}
impl<S: Simd> SimdBase<S> for f64x2<S> {
    type Element = f64;
    const N: usize = 2;
    type Mask = mask64x2<S>;
    type Block = f64x2<S>;
    type Array = [f64; 2];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f64] {
        self.simd.as_array_ref_f64x2(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f64] {
        self.simd.as_array_mut_f64x2(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f64]) -> Self {
        simd.load_array_ref_f64x2(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f64]) {
        self.simd
            .store_array_f64x2(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f64) -> Self {
        simd.splat_f64x2(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f64) -> Self {
        simd.load_array_f64x2(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f64x2::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f64x2::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f64x2<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f64x2(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f64x2(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f64x2(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f64x2(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f64x2(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f64x2(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f64x2(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f64x2(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f64x2(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for f64x2<S> {
    type Combined = f64x4<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_f64x2(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 2 64-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(16))]
pub struct mask64x2<S: Simd> {
    pub(crate) val: S::mask64x2,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i64; 2], S> for mask64x2<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i64; 2]) -> Self {
        simd.load_array_mask64x2(val)
    }
}
impl<S: Simd> From<mask64x2<S>> for [i64; 2] {
    #[inline(always)]
    fn from(value: mask64x2<S>) -> Self {
        value.simd.as_array_mask64x2(value)
    }
}
impl<S: Simd> core::ops::Deref for mask64x2<S> {
    type Target = [i64; 2];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask64x2(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask64x2<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask64x2(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask64x2<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask64x2",
            &self.simd,
            self.simd.as_array_ref_mask64x2(self),
        )
    }
}
impl<S: Simd> SimdFrom<i64, S> for mask64x2<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i64) -> Self {
        simd.splat_mask64x2(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask64x2<S> {
    type Output = i64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask64x2(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask64x2<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask64x2(self)[i]
    }
}
impl<S: Simd> Select<mask64x2<S>> for mask64x2<S> {
    #[inline(always)]
    fn select(self, if_true: mask64x2<S>, if_false: mask64x2<S>) -> mask64x2<S> {
        self.simd.select_mask64x2(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask64x2<S> {
    type Bytes = u8x16<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask64x2(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask64x2(value)
    }
}
impl<S: Simd> SimdBase<S> for mask64x2<S> {
    type Element = i64;
    const N: usize = 2;
    type Mask = mask64x2<S>;
    type Block = mask64x2<S>;
    type Array = [i64; 2];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i64] {
        self.simd.as_array_ref_mask64x2(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i64] {
        self.simd.as_array_mut_mask64x2(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i64]) -> Self {
        simd.load_array_ref_mask64x2(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i64]) {
        self.simd
            .store_array_mask64x2(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i64) -> Self {
        simd.splat_mask64x2(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i64) -> Self {
        simd.load_array_mask64x2(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask64x2::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask64x2::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask64x2<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask64x2(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask64x2(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask64x2(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask64x2(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask64x2(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask64x2<S> {
    type Combined = mask64x4<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask64x2(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 8 [`f32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f32x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f32x8::splat(simd, 1.0);\n    let b = f32x8::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f32x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);\n\n    // From an array:\n    let d = f32x8::simd_from(simd, [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);\n\n    // From an element-wise function:\n    let e = f32x8::from_fn(simd, |i| i as f32);\n    # use fearless_simd::f32x4;\n    // From `Self::Block`:\n    let f = f32x8::block_splat(f32x4::simd_from(simd, [1.0, 2.0, 3.0, 4.0]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct f32x8<S: Simd> {
    pub(crate) val: S::f32x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f32; 8], S> for f32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f32; 8]) -> Self {
        simd.load_array_f32x8(val)
    }
}
impl<S: Simd> From<f32x8<S>> for [f32; 8] {
    #[inline(always)]
    fn from(value: f32x8<S>) -> Self {
        value.simd.as_array_f32x8(value)
    }
}
impl<S: Simd> core::ops::Deref for f32x8<S> {
    type Target = [f32; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f32x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f32x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f32x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f32x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "f32x8", &self.simd, self.simd.as_array_ref_f32x8(self))
    }
}
impl<S: Simd> SimdFrom<f32, S> for f32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f32) -> Self {
        simd.splat_f32x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f32x8<S> {
    type Output = f32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f32x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f32x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f32x8(self)[i]
    }
}
impl<S: Simd> Select<f32x8<S>> for mask32x8<S> {
    #[inline(always)]
    fn select(self, if_true: f32x8<S>, if_false: f32x8<S>) -> f32x8<S> {
        self.simd.select_f32x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f32x8<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f32x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f32x8(value)
    }
}
impl<S: Simd> SimdBase<S> for f32x8<S> {
    type Element = f32;
    const N: usize = 8;
    type Mask = mask32x8<S>;
    type Block = f32x4<S>;
    type Array = [f32; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f32] {
        self.simd.as_array_ref_f32x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f32] {
        self.simd.as_array_mut_f32x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f32]) -> Self {
        simd.load_array_ref_f32x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f32]) {
        self.simd
            .store_array_f32x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f32) -> Self {
        simd.splat_f32x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_f32x4(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f32) -> Self {
        simd.load_array_f32x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f32x8<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f32x8(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f32x8(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f32x8(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f32x8(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f32x8(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f32x8(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f32x8(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f32x8(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f32x8(self)
    }
}
impl<S: Simd> SimdCvtFloat<u32x8<S>> for f32x8<S> {
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: u32x8<S>) -> Self {
        x.simd.cvt_f32_u32x8(x)
    }
}
impl<S: Simd> SimdCvtFloat<i32x8<S>> for f32x8<S> {
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: i32x8<S>) -> Self {
        x.simd.cvt_f32_i32x8(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for f32x8<S> {
    type Split = f32x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_f32x8(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for f32x8<S> {
    type Combined = f32x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_f32x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 32 [`i8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i8x32};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i8x32::splat(simd, 1);\n    let b = i8x32::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i8x32::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an array:\n    let d = i8x32::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an element-wise function:\n    let e = i8x32::from_fn(simd, |i| i as i8);\n    # use fearless_simd::i8x16;\n    // From `Self::Block`:\n    let f = i8x32::block_splat(i8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct i8x32<S: Simd> {
    pub(crate) val: S::i8x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 32], S> for i8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 32]) -> Self {
        simd.load_array_i8x32(val)
    }
}
impl<S: Simd> From<i8x32<S>> for [i8; 32] {
    #[inline(always)]
    fn from(value: i8x32<S>) -> Self {
        value.simd.as_array_i8x32(value)
    }
}
impl<S: Simd> core::ops::Deref for i8x32<S> {
    type Target = [i8; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i8x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i8x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i8x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i8x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i8x32", &self.simd, self.simd.as_array_ref_i8x32(self))
    }
}
impl<S: Simd> SimdFrom<i8, S> for i8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_i8x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i8x32<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i8x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i8x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i8x32(self)[i]
    }
}
impl<S: Simd> Select<i8x32<S>> for mask8x32<S> {
    #[inline(always)]
    fn select(self, if_true: i8x32<S>, if_false: i8x32<S>) -> i8x32<S> {
        self.simd.select_i8x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i8x32<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i8x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i8x32(value)
    }
}
impl<S: Simd> SimdBase<S> for i8x32<S> {
    type Element = i8;
    const N: usize = 32;
    type Mask = mask8x32<S>;
    type Block = i8x16<S>;
    type Array = [i8; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_i8x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_i8x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_i8x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_i8x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_i8x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_i8x16(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_i8x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i8x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i8x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for i8x32<S> {
    type Split = i8x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i8x32(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for i8x32<S> {
    type Combined = i8x64<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i8x32(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 32 [`u8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u8x32};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u8x32::splat(simd, 1);\n    let b = u8x32::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u8x32::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an array:\n    let d = u8x32::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an element-wise function:\n    let e = u8x32::from_fn(simd, |i| i as u8);\n    # use fearless_simd::u8x16;\n    // From `Self::Block`:\n    let f = u8x32::block_splat(u8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct u8x32<S: Simd> {
    pub(crate) val: S::u8x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u8; 32], S> for u8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u8; 32]) -> Self {
        simd.load_array_u8x32(val)
    }
}
impl<S: Simd> From<u8x32<S>> for [u8; 32] {
    #[inline(always)]
    fn from(value: u8x32<S>) -> Self {
        value.simd.as_array_u8x32(value)
    }
}
impl<S: Simd> core::ops::Deref for u8x32<S> {
    type Target = [u8; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u8x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u8x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u8x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u8x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u8x32", &self.simd, self.simd.as_array_ref_u8x32(self))
    }
}
impl<S: Simd> SimdFrom<u8, S> for u8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u8) -> Self {
        simd.splat_u8x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u8x32<S> {
    type Output = u8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u8x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u8x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u8x32(self)[i]
    }
}
impl<S: Simd> Select<u8x32<S>> for mask8x32<S> {
    #[inline(always)]
    fn select(self, if_true: u8x32<S>, if_false: u8x32<S>) -> u8x32<S> {
        self.simd.select_u8x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u8x32<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u8x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u8x32(value)
    }
}
impl<S: Simd> SimdBase<S> for u8x32<S> {
    type Element = u8;
    const N: usize = 32;
    type Mask = mask8x32<S>;
    type Block = u8x16<S>;
    type Array = [u8; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u8] {
        self.simd.as_array_ref_u8x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u8] {
        self.simd.as_array_mut_u8x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u8]) -> Self {
        simd.load_array_ref_u8x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u8]) {
        self.simd
            .store_array_u8x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u8) -> Self {
        simd.splat_u8x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_u8x16(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u8) -> Self {
        simd.load_array_u8x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u8x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u8x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for u8x32<S> {
    type Split = u8x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u8x32(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for u8x32<S> {
    type Combined = u8x64<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u8x32(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 32 8-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct mask8x32<S: Simd> {
    pub(crate) val: S::mask8x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 32], S> for mask8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 32]) -> Self {
        simd.load_array_mask8x32(val)
    }
}
impl<S: Simd> From<mask8x32<S>> for [i8; 32] {
    #[inline(always)]
    fn from(value: mask8x32<S>) -> Self {
        value.simd.as_array_mask8x32(value)
    }
}
impl<S: Simd> core::ops::Deref for mask8x32<S> {
    type Target = [i8; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask8x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask8x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask8x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask8x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask8x32",
            &self.simd,
            self.simd.as_array_ref_mask8x32(self),
        )
    }
}
impl<S: Simd> SimdFrom<i8, S> for mask8x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_mask8x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask8x32<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask8x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask8x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask8x32(self)[i]
    }
}
impl<S: Simd> Select<mask8x32<S>> for mask8x32<S> {
    #[inline(always)]
    fn select(self, if_true: mask8x32<S>, if_false: mask8x32<S>) -> mask8x32<S> {
        self.simd.select_mask8x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask8x32<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask8x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask8x32(value)
    }
}
impl<S: Simd> SimdBase<S> for mask8x32<S> {
    type Element = i8;
    const N: usize = 32;
    type Mask = mask8x32<S>;
    type Block = mask8x16<S>;
    type Array = [i8; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_mask8x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_mask8x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_mask8x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_mask8x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_mask8x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_mask8x16(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_mask8x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask8x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask8x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask8x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask8x32(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask8x32(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask8x32(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask8x32(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask8x32<S> {
    type Split = mask8x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask8x32(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask8x32<S> {
    type Combined = mask8x64<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask8x32(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 16 [`i16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i16x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i16x16::splat(simd, 1);\n    let b = i16x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i16x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = i16x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = i16x16::from_fn(simd, |i| i as i16);\n    # use fearless_simd::i16x8;\n    // From `Self::Block`:\n    let f = i16x16::block_splat(i16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct i16x16<S: Simd> {
    pub(crate) val: S::i16x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 16], S> for i16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 16]) -> Self {
        simd.load_array_i16x16(val)
    }
}
impl<S: Simd> From<i16x16<S>> for [i16; 16] {
    #[inline(always)]
    fn from(value: i16x16<S>) -> Self {
        value.simd.as_array_i16x16(value)
    }
}
impl<S: Simd> core::ops::Deref for i16x16<S> {
    type Target = [i16; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i16x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i16x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i16x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i16x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "i16x16",
            &self.simd,
            self.simd.as_array_ref_i16x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<i16, S> for i16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_i16x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i16x16<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i16x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i16x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i16x16(self)[i]
    }
}
impl<S: Simd> Select<i16x16<S>> for mask16x16<S> {
    #[inline(always)]
    fn select(self, if_true: i16x16<S>, if_false: i16x16<S>) -> i16x16<S> {
        self.simd.select_i16x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i16x16<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i16x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i16x16(value)
    }
}
impl<S: Simd> SimdBase<S> for i16x16<S> {
    type Element = i16;
    const N: usize = 16;
    type Mask = mask16x16<S>;
    type Block = i16x8<S>;
    type Array = [i16; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_i16x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_i16x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_i16x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_i16x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_i16x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_i16x8(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_i16x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i16x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i16x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for i16x16<S> {
    type Split = i16x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i16x16(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for i16x16<S> {
    type Combined = i16x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i16x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 16 [`u16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u16x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u16x16::splat(simd, 1);\n    let b = u16x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u16x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = u16x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = u16x16::from_fn(simd, |i| i as u16);\n    # use fearless_simd::u16x8;\n    // From `Self::Block`:\n    let f = u16x16::block_splat(u16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct u16x16<S: Simd> {
    pub(crate) val: S::u16x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u16; 16], S> for u16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u16; 16]) -> Self {
        simd.load_array_u16x16(val)
    }
}
impl<S: Simd> From<u16x16<S>> for [u16; 16] {
    #[inline(always)]
    fn from(value: u16x16<S>) -> Self {
        value.simd.as_array_u16x16(value)
    }
}
impl<S: Simd> core::ops::Deref for u16x16<S> {
    type Target = [u16; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u16x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u16x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u16x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u16x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "u16x16",
            &self.simd,
            self.simd.as_array_ref_u16x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<u16, S> for u16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u16) -> Self {
        simd.splat_u16x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u16x16<S> {
    type Output = u16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u16x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u16x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u16x16(self)[i]
    }
}
impl<S: Simd> Select<u16x16<S>> for mask16x16<S> {
    #[inline(always)]
    fn select(self, if_true: u16x16<S>, if_false: u16x16<S>) -> u16x16<S> {
        self.simd.select_u16x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u16x16<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u16x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u16x16(value)
    }
}
impl<S: Simd> SimdBase<S> for u16x16<S> {
    type Element = u16;
    const N: usize = 16;
    type Mask = mask16x16<S>;
    type Block = u16x8<S>;
    type Array = [u16; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u16] {
        self.simd.as_array_ref_u16x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u16] {
        self.simd.as_array_mut_u16x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u16]) -> Self {
        simd.load_array_ref_u16x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u16]) {
        self.simd
            .store_array_u16x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u16) -> Self {
        simd.splat_u16x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_u16x8(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u16) -> Self {
        simd.load_array_u16x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u16x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u16x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for u16x16<S> {
    type Split = u16x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u16x16(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for u16x16<S> {
    type Combined = u16x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u16x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 16 16-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct mask16x16<S: Simd> {
    pub(crate) val: S::mask16x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 16], S> for mask16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 16]) -> Self {
        simd.load_array_mask16x16(val)
    }
}
impl<S: Simd> From<mask16x16<S>> for [i16; 16] {
    #[inline(always)]
    fn from(value: mask16x16<S>) -> Self {
        value.simd.as_array_mask16x16(value)
    }
}
impl<S: Simd> core::ops::Deref for mask16x16<S> {
    type Target = [i16; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask16x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask16x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask16x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask16x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask16x16",
            &self.simd,
            self.simd.as_array_ref_mask16x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<i16, S> for mask16x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_mask16x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask16x16<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask16x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask16x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask16x16(self)[i]
    }
}
impl<S: Simd> Select<mask16x16<S>> for mask16x16<S> {
    #[inline(always)]
    fn select(self, if_true: mask16x16<S>, if_false: mask16x16<S>) -> mask16x16<S> {
        self.simd.select_mask16x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask16x16<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask16x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask16x16(value)
    }
}
impl<S: Simd> SimdBase<S> for mask16x16<S> {
    type Element = i16;
    const N: usize = 16;
    type Mask = mask16x16<S>;
    type Block = mask16x8<S>;
    type Array = [i16; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_mask16x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_mask16x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_mask16x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_mask16x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_mask16x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_mask16x8(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_mask16x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask16x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask16x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask16x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask16x16(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask16x16(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask16x16(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask16x16(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask16x16<S> {
    type Split = mask16x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask16x16(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask16x16<S> {
    type Combined = mask16x32<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask16x16(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 8 [`i32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i32x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i32x8::splat(simd, 1);\n    let b = i32x8::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an array:\n    let d = i32x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an element-wise function:\n    let e = i32x8::from_fn(simd, |i| i as i32);\n    # use fearless_simd::i32x4;\n    // From `Self::Block`:\n    let f = i32x8::block_splat(i32x4::simd_from(simd, [1, 2, 3, 4]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct i32x8<S: Simd> {
    pub(crate) val: S::i32x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 8], S> for i32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 8]) -> Self {
        simd.load_array_i32x8(val)
    }
}
impl<S: Simd> From<i32x8<S>> for [i32; 8] {
    #[inline(always)]
    fn from(value: i32x8<S>) -> Self {
        value.simd.as_array_i32x8(value)
    }
}
impl<S: Simd> core::ops::Deref for i32x8<S> {
    type Target = [i32; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i32x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i32x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i32x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i32x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i32x8", &self.simd, self.simd.as_array_ref_i32x8(self))
    }
}
impl<S: Simd> SimdFrom<i32, S> for i32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_i32x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i32x8<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i32x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i32x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i32x8(self)[i]
    }
}
impl<S: Simd> Select<i32x8<S>> for mask32x8<S> {
    #[inline(always)]
    fn select(self, if_true: i32x8<S>, if_false: i32x8<S>) -> i32x8<S> {
        self.simd.select_i32x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i32x8<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i32x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i32x8(value)
    }
}
impl<S: Simd> SimdBase<S> for i32x8<S> {
    type Element = i32;
    const N: usize = 8;
    type Mask = mask32x8<S>;
    type Block = i32x4<S>;
    type Array = [i32; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_i32x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_i32x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_i32x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_i32x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_i32x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_i32x4(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_i32x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i32x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x8<S>> for i32x8<S> {
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    #[inline(always)]
    fn truncate_from(x: f32x8<S>) -> Self {
        x.simd.cvt_i32_f32x8(x)
    }
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x8<S>) -> Self {
        x.simd.cvt_i32_precise_f32x8(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for i32x8<S> {
    type Split = i32x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i32x8(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for i32x8<S> {
    type Combined = i32x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_i32x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 8 [`u32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u32x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u32x8::splat(simd, 1);\n    let b = u32x8::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u32x8::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an array:\n    let d = u32x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]);\n\n    // From an element-wise function:\n    let e = u32x8::from_fn(simd, |i| i as u32);\n    # use fearless_simd::u32x4;\n    // From `Self::Block`:\n    let f = u32x8::block_splat(u32x4::simd_from(simd, [1, 2, 3, 4]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct u32x8<S: Simd> {
    pub(crate) val: S::u32x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u32; 8], S> for u32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u32; 8]) -> Self {
        simd.load_array_u32x8(val)
    }
}
impl<S: Simd> From<u32x8<S>> for [u32; 8] {
    #[inline(always)]
    fn from(value: u32x8<S>) -> Self {
        value.simd.as_array_u32x8(value)
    }
}
impl<S: Simd> core::ops::Deref for u32x8<S> {
    type Target = [u32; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u32x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u32x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u32x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u32x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u32x8", &self.simd, self.simd.as_array_ref_u32x8(self))
    }
}
impl<S: Simd> SimdFrom<u32, S> for u32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u32) -> Self {
        simd.splat_u32x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u32x8<S> {
    type Output = u32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u32x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u32x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u32x8(self)[i]
    }
}
impl<S: Simd> Select<u32x8<S>> for mask32x8<S> {
    #[inline(always)]
    fn select(self, if_true: u32x8<S>, if_false: u32x8<S>) -> u32x8<S> {
        self.simd.select_u32x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u32x8<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u32x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u32x8(value)
    }
}
impl<S: Simd> SimdBase<S> for u32x8<S> {
    type Element = u32;
    const N: usize = 8;
    type Mask = mask32x8<S>;
    type Block = u32x4<S>;
    type Array = [u32; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u32] {
        self.simd.as_array_ref_u32x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u32] {
        self.simd.as_array_mut_u32x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u32]) -> Self {
        simd.load_array_ref_u32x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u32]) {
        self.simd
            .store_array_u32x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u32) -> Self {
        simd.splat_u32x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_u32x4(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u32) -> Self {
        simd.load_array_u32x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u32x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x8<S>> for u32x8<S> {
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    #[inline(always)]
    fn truncate_from(x: f32x8<S>) -> Self {
        x.simd.cvt_u32_f32x8(x)
    }
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x8<S>) -> Self {
        x.simd.cvt_u32_precise_f32x8(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for u32x8<S> {
    type Split = u32x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u32x8(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for u32x8<S> {
    type Combined = u32x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_u32x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 8 32-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct mask32x8<S: Simd> {
    pub(crate) val: S::mask32x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 8], S> for mask32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 8]) -> Self {
        simd.load_array_mask32x8(val)
    }
}
impl<S: Simd> From<mask32x8<S>> for [i32; 8] {
    #[inline(always)]
    fn from(value: mask32x8<S>) -> Self {
        value.simd.as_array_mask32x8(value)
    }
}
impl<S: Simd> core::ops::Deref for mask32x8<S> {
    type Target = [i32; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask32x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask32x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask32x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask32x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask32x8",
            &self.simd,
            self.simd.as_array_ref_mask32x8(self),
        )
    }
}
impl<S: Simd> SimdFrom<i32, S> for mask32x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_mask32x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask32x8<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask32x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask32x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask32x8(self)[i]
    }
}
impl<S: Simd> Select<mask32x8<S>> for mask32x8<S> {
    #[inline(always)]
    fn select(self, if_true: mask32x8<S>, if_false: mask32x8<S>) -> mask32x8<S> {
        self.simd.select_mask32x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask32x8<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask32x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask32x8(value)
    }
}
impl<S: Simd> SimdBase<S> for mask32x8<S> {
    type Element = i32;
    const N: usize = 8;
    type Mask = mask32x8<S>;
    type Block = mask32x4<S>;
    type Array = [i32; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_mask32x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_mask32x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_mask32x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_mask32x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_mask32x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_mask32x4(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_mask32x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask32x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask32x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask32x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask32x8(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask32x8(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask32x8(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask32x8(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask32x8<S> {
    type Split = mask32x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask32x8(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask32x8<S> {
    type Combined = mask32x16<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask32x8(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 4 [`f64`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f64x4};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f64x4::splat(simd, 1.0);\n    let b = f64x4::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f64x4::from_slice(simd, &[1.0, 2.0, 3.0, 4.0]);\n\n    // From an array:\n    let d = f64x4::simd_from(simd, [1.0, 2.0, 3.0, 4.0]);\n\n    // From an element-wise function:\n    let e = f64x4::from_fn(simd, |i| i as f64);\n    # use fearless_simd::f64x2;\n    // From `Self::Block`:\n    let f = f64x4::block_splat(f64x2::simd_from(simd, [1.0, 2.0]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct f64x4<S: Simd> {
    pub(crate) val: S::f64x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f64; 4], S> for f64x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f64; 4]) -> Self {
        simd.load_array_f64x4(val)
    }
}
impl<S: Simd> From<f64x4<S>> for [f64; 4] {
    #[inline(always)]
    fn from(value: f64x4<S>) -> Self {
        value.simd.as_array_f64x4(value)
    }
}
impl<S: Simd> core::ops::Deref for f64x4<S> {
    type Target = [f64; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f64x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f64x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f64x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f64x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "f64x4", &self.simd, self.simd.as_array_ref_f64x4(self))
    }
}
impl<S: Simd> SimdFrom<f64, S> for f64x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f64) -> Self {
        simd.splat_f64x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f64x4<S> {
    type Output = f64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f64x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f64x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f64x4(self)[i]
    }
}
impl<S: Simd> Select<f64x4<S>> for mask64x4<S> {
    #[inline(always)]
    fn select(self, if_true: f64x4<S>, if_false: f64x4<S>) -> f64x4<S> {
        self.simd.select_f64x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f64x4<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f64x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f64x4(value)
    }
}
impl<S: Simd> SimdBase<S> for f64x4<S> {
    type Element = f64;
    const N: usize = 4;
    type Mask = mask64x4<S>;
    type Block = f64x2<S>;
    type Array = [f64; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f64] {
        self.simd.as_array_ref_f64x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f64] {
        self.simd.as_array_mut_f64x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f64]) -> Self {
        simd.load_array_ref_f64x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f64]) {
        self.simd
            .store_array_f64x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f64) -> Self {
        simd.splat_f64x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_f64x2(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f64) -> Self {
        simd.load_array_f64x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f64x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f64x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f64x4<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f64x4(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f64x4(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f64x4(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f64x4(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f64x4(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f64x4(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f64x4(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f64x4(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f64x4(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for f64x4<S> {
    type Split = f64x2<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_f64x4(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for f64x4<S> {
    type Combined = f64x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_f64x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD mask of 4 64-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(32))]
pub struct mask64x4<S: Simd> {
    pub(crate) val: S::mask64x4,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i64; 4], S> for mask64x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i64; 4]) -> Self {
        simd.load_array_mask64x4(val)
    }
}
impl<S: Simd> From<mask64x4<S>> for [i64; 4] {
    #[inline(always)]
    fn from(value: mask64x4<S>) -> Self {
        value.simd.as_array_mask64x4(value)
    }
}
impl<S: Simd> core::ops::Deref for mask64x4<S> {
    type Target = [i64; 4];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask64x4(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask64x4<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask64x4(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask64x4<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask64x4",
            &self.simd,
            self.simd.as_array_ref_mask64x4(self),
        )
    }
}
impl<S: Simd> SimdFrom<i64, S> for mask64x4<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i64) -> Self {
        simd.splat_mask64x4(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask64x4<S> {
    type Output = i64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask64x4(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask64x4<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask64x4(self)[i]
    }
}
impl<S: Simd> Select<mask64x4<S>> for mask64x4<S> {
    #[inline(always)]
    fn select(self, if_true: mask64x4<S>, if_false: mask64x4<S>) -> mask64x4<S> {
        self.simd.select_mask64x4(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask64x4<S> {
    type Bytes = u8x32<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask64x4(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask64x4(value)
    }
}
impl<S: Simd> SimdBase<S> for mask64x4<S> {
    type Element = i64;
    const N: usize = 4;
    type Mask = mask64x4<S>;
    type Block = mask64x2<S>;
    type Array = [i64; 4];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i64] {
        self.simd.as_array_ref_mask64x4(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i64] {
        self.simd.as_array_mut_mask64x4(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i64]) -> Self {
        simd.load_array_ref_mask64x4(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i64]) {
        self.simd
            .store_array_mask64x4(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i64) -> Self {
        simd.splat_mask64x4(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        block.simd.combine_mask64x2(block, block)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i64) -> Self {
        simd.load_array_mask64x4(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask64x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask64x4::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask64x4<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask64x4(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask64x4(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask64x4(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask64x4(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask64x4(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask64x4<S> {
    type Split = mask64x2<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask64x4(self)
    }
}
impl<S: Simd> crate::SimdCombine<S> for mask64x4<S> {
    type Combined = mask64x8<S>;
    #[inline(always)]
    fn combine(self, rhs: impl SimdInto<Self, S>) -> Self::Combined {
        self.simd.combine_mask64x4(self, rhs.simd_into(self.simd))
    }
}
#[doc = "A SIMD vector of 16 [`f32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f32x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f32x16::splat(simd, 1.0);\n    let b = f32x16::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f32x16::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0]);\n\n    // From an array:\n    let d = f32x16::simd_from(simd, [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0]);\n\n    // From an element-wise function:\n    let e = f32x16::from_fn(simd, |i| i as f32);\n    # use fearless_simd::f32x4;\n    // From `Self::Block`:\n    let f = f32x16::block_splat(f32x4::simd_from(simd, [1.0, 2.0, 3.0, 4.0]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct f32x16<S: Simd> {
    pub(crate) val: S::f32x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f32; 16], S> for f32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f32; 16]) -> Self {
        simd.load_array_f32x16(val)
    }
}
impl<S: Simd> From<f32x16<S>> for [f32; 16] {
    #[inline(always)]
    fn from(value: f32x16<S>) -> Self {
        value.simd.as_array_f32x16(value)
    }
}
impl<S: Simd> core::ops::Deref for f32x16<S> {
    type Target = [f32; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f32x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f32x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f32x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f32x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "f32x16",
            &self.simd,
            self.simd.as_array_ref_f32x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<f32, S> for f32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f32) -> Self {
        simd.splat_f32x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f32x16<S> {
    type Output = f32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f32x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f32x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f32x16(self)[i]
    }
}
impl<S: Simd> Select<f32x16<S>> for mask32x16<S> {
    #[inline(always)]
    fn select(self, if_true: f32x16<S>, if_false: f32x16<S>) -> f32x16<S> {
        self.simd.select_f32x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f32x16<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f32x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f32x16(value)
    }
}
impl<S: Simd> SimdBase<S> for f32x16<S> {
    type Element = f32;
    const N: usize = 16;
    type Mask = mask32x16<S>;
    type Block = f32x4<S>;
    type Array = [f32; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f32] {
        self.simd.as_array_ref_f32x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f32] {
        self.simd.as_array_mut_f32x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f32]) -> Self {
        simd.load_array_ref_f32x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f32]) {
        self.simd
            .store_array_f32x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f32) -> Self {
        simd.splat_f32x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_f32x4(block, block);
        block2.simd.combine_f32x8(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f32) -> Self {
        simd.load_array_f32x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f32x16<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f32x16(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f32x16(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f32x16(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f32x16(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f32x16(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f32x16(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f32x16(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f32x16(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f32x16(self)
    }
}
impl<S: Simd> SimdCvtFloat<u32x16<S>> for f32x16<S> {
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: u32x16<S>) -> Self {
        x.simd.cvt_f32_u32x16(x)
    }
}
impl<S: Simd> SimdCvtFloat<i32x16<S>> for f32x16<S> {
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    #[inline(always)]
    fn float_from(x: i32x16<S>) -> Self {
        x.simd.cvt_f32_i32x16(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for f32x16<S> {
    type Split = f32x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_f32x16(self)
    }
}
#[doc = "A SIMD vector of 64 [`i8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i8x64};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i8x64::splat(simd, 1);\n    let b = i8x64::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i8x64::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n\n    // From an array:\n    let d = i8x64::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n\n    // From an element-wise function:\n    let e = i8x64::from_fn(simd, |i| i as i8);\n    # use fearless_simd::i8x16;\n    // From `Self::Block`:\n    let f = i8x64::block_splat(i8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct i8x64<S: Simd> {
    pub(crate) val: S::i8x64,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 64], S> for i8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 64]) -> Self {
        simd.load_array_i8x64(val)
    }
}
impl<S: Simd> From<i8x64<S>> for [i8; 64] {
    #[inline(always)]
    fn from(value: i8x64<S>) -> Self {
        value.simd.as_array_i8x64(value)
    }
}
impl<S: Simd> core::ops::Deref for i8x64<S> {
    type Target = [i8; 64];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i8x64(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i8x64<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i8x64(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i8x64<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "i8x64", &self.simd, self.simd.as_array_ref_i8x64(self))
    }
}
impl<S: Simd> SimdFrom<i8, S> for i8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_i8x64(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i8x64<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i8x64(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i8x64<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i8x64(self)[i]
    }
}
impl<S: Simd> Select<i8x64<S>> for mask8x64<S> {
    #[inline(always)]
    fn select(self, if_true: i8x64<S>, if_false: i8x64<S>) -> i8x64<S> {
        self.simd.select_i8x64(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i8x64<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i8x64(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i8x64(value)
    }
}
impl<S: Simd> SimdBase<S> for i8x64<S> {
    type Element = i8;
    const N: usize = 64;
    type Mask = mask8x64<S>;
    type Block = i8x16<S>;
    type Array = [i8; 64];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_i8x64(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_i8x64(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_i8x64(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_i8x64(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_i8x64(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_i8x16(block, block);
        block2.simd.combine_i8x32(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_i8x64(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i8x64<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i8x64(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for i8x64<S> {
    type Split = i8x32<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i8x64(self)
    }
}
#[doc = "A SIMD vector of 64 [`u8`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u8x64};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u8x64::splat(simd, 1);\n    let b = u8x64::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u8x64::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n\n    // From an array:\n    let d = u8x64::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n\n    // From an element-wise function:\n    let e = u8x64::from_fn(simd, |i| i as u8);\n    # use fearless_simd::u8x16;\n    // From `Self::Block`:\n    let f = u8x64::block_splat(u8x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct u8x64<S: Simd> {
    pub(crate) val: S::u8x64,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u8; 64], S> for u8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u8; 64]) -> Self {
        simd.load_array_u8x64(val)
    }
}
impl<S: Simd> From<u8x64<S>> for [u8; 64] {
    #[inline(always)]
    fn from(value: u8x64<S>) -> Self {
        value.simd.as_array_u8x64(value)
    }
}
impl<S: Simd> core::ops::Deref for u8x64<S> {
    type Target = [u8; 64];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u8x64(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u8x64<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u8x64(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u8x64<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "u8x64", &self.simd, self.simd.as_array_ref_u8x64(self))
    }
}
impl<S: Simd> SimdFrom<u8, S> for u8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u8) -> Self {
        simd.splat_u8x64(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u8x64<S> {
    type Output = u8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u8x64(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u8x64<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u8x64(self)[i]
    }
}
impl<S: Simd> Select<u8x64<S>> for mask8x64<S> {
    #[inline(always)]
    fn select(self, if_true: u8x64<S>, if_false: u8x64<S>) -> u8x64<S> {
        self.simd.select_u8x64(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u8x64<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u8x64(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u8x64(value)
    }
}
impl<S: Simd> SimdBase<S> for u8x64<S> {
    type Element = u8;
    const N: usize = 64;
    type Mask = mask8x64<S>;
    type Block = u8x16<S>;
    type Array = [u8; 64];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u8] {
        self.simd.as_array_ref_u8x64(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u8] {
        self.simd.as_array_mut_u8x64(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u8]) -> Self {
        simd.load_array_ref_u8x64(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u8]) {
        self.simd
            .store_array_u8x64(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u8) -> Self {
        simd.splat_u8x64(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_u8x16(block, block);
        block2.simd.combine_u8x32(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u8) -> Self {
        simd.load_array_u8x64(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u8x64<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u8x64(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for u8x64<S> {
    type Split = u8x32<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u8x64(self)
    }
}
#[doc = "A SIMD mask of 64 8-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct mask8x64<S: Simd> {
    pub(crate) val: S::mask8x64,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i8; 64], S> for mask8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i8; 64]) -> Self {
        simd.load_array_mask8x64(val)
    }
}
impl<S: Simd> From<mask8x64<S>> for [i8; 64] {
    #[inline(always)]
    fn from(value: mask8x64<S>) -> Self {
        value.simd.as_array_mask8x64(value)
    }
}
impl<S: Simd> core::ops::Deref for mask8x64<S> {
    type Target = [i8; 64];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask8x64(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask8x64<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask8x64(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask8x64<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask8x64",
            &self.simd,
            self.simd.as_array_ref_mask8x64(self),
        )
    }
}
impl<S: Simd> SimdFrom<i8, S> for mask8x64<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i8) -> Self {
        simd.splat_mask8x64(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask8x64<S> {
    type Output = i8;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask8x64(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask8x64<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask8x64(self)[i]
    }
}
impl<S: Simd> Select<mask8x64<S>> for mask8x64<S> {
    #[inline(always)]
    fn select(self, if_true: mask8x64<S>, if_false: mask8x64<S>) -> mask8x64<S> {
        self.simd.select_mask8x64(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask8x64<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask8x64(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask8x64(value)
    }
}
impl<S: Simd> SimdBase<S> for mask8x64<S> {
    type Element = i8;
    const N: usize = 64;
    type Mask = mask8x64<S>;
    type Block = mask8x16<S>;
    type Array = [i8; 64];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i8] {
        self.simd.as_array_ref_mask8x64(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i8] {
        self.simd.as_array_mut_mask8x64(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i8]) -> Self {
        simd.load_array_ref_mask8x64(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i8]) {
        self.simd
            .store_array_mask8x64(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i8) -> Self {
        simd.splat_mask8x64(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_mask8x16(block, block);
        block2.simd.combine_mask8x32(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i8) -> Self {
        simd.load_array_mask8x64(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask8x64::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask8x64<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask8x64(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask8x64(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask8x64(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask8x64(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask8x64(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask8x64<S> {
    type Split = mask8x32<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask8x64(self)
    }
}
#[doc = "A SIMD vector of 32 [`i16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i16x32};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i16x32::splat(simd, 1);\n    let b = i16x32::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i16x32::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an array:\n    let d = i16x32::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an element-wise function:\n    let e = i16x32::from_fn(simd, |i| i as i16);\n    # use fearless_simd::i16x8;\n    // From `Self::Block`:\n    let f = i16x32::block_splat(i16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct i16x32<S: Simd> {
    pub(crate) val: S::i16x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 32], S> for i16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 32]) -> Self {
        simd.load_array_i16x32(val)
    }
}
impl<S: Simd> From<i16x32<S>> for [i16; 32] {
    #[inline(always)]
    fn from(value: i16x32<S>) -> Self {
        value.simd.as_array_i16x32(value)
    }
}
impl<S: Simd> core::ops::Deref for i16x32<S> {
    type Target = [i16; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i16x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i16x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i16x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i16x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "i16x32",
            &self.simd,
            self.simd.as_array_ref_i16x32(self),
        )
    }
}
impl<S: Simd> SimdFrom<i16, S> for i16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_i16x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i16x32<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i16x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i16x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i16x32(self)[i]
    }
}
impl<S: Simd> Select<i16x32<S>> for mask16x32<S> {
    #[inline(always)]
    fn select(self, if_true: i16x32<S>, if_false: i16x32<S>) -> i16x32<S> {
        self.simd.select_i16x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i16x32<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i16x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i16x32(value)
    }
}
impl<S: Simd> SimdBase<S> for i16x32<S> {
    type Element = i16;
    const N: usize = 32;
    type Mask = mask16x32<S>;
    type Block = i16x8<S>;
    type Array = [i16; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_i16x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_i16x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_i16x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_i16x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_i16x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_i16x8(block, block);
        block2.simd.combine_i16x16(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_i16x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i16x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i16x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for i16x32<S> {
    type Split = i16x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i16x32(self)
    }
}
#[doc = "A SIMD vector of 32 [`u16`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u16x32};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u16x32::splat(simd, 1);\n    let b = u16x32::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u16x32::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an array:\n    let d = u16x32::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);\n\n    // From an element-wise function:\n    let e = u16x32::from_fn(simd, |i| i as u16);\n    # use fearless_simd::u16x8;\n    // From `Self::Block`:\n    let f = u16x32::block_splat(u16x8::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct u16x32<S: Simd> {
    pub(crate) val: S::u16x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u16; 32], S> for u16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u16; 32]) -> Self {
        simd.load_array_u16x32(val)
    }
}
impl<S: Simd> From<u16x32<S>> for [u16; 32] {
    #[inline(always)]
    fn from(value: u16x32<S>) -> Self {
        value.simd.as_array_u16x32(value)
    }
}
impl<S: Simd> core::ops::Deref for u16x32<S> {
    type Target = [u16; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u16x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u16x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u16x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u16x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "u16x32",
            &self.simd,
            self.simd.as_array_ref_u16x32(self),
        )
    }
}
impl<S: Simd> SimdFrom<u16, S> for u16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u16) -> Self {
        simd.splat_u16x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u16x32<S> {
    type Output = u16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u16x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u16x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u16x32(self)[i]
    }
}
impl<S: Simd> Select<u16x32<S>> for mask16x32<S> {
    #[inline(always)]
    fn select(self, if_true: u16x32<S>, if_false: u16x32<S>) -> u16x32<S> {
        self.simd.select_u16x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u16x32<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u16x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u16x32(value)
    }
}
impl<S: Simd> SimdBase<S> for u16x32<S> {
    type Element = u16;
    const N: usize = 32;
    type Mask = mask16x32<S>;
    type Block = u16x8<S>;
    type Array = [u16; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u16] {
        self.simd.as_array_ref_u16x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u16] {
        self.simd.as_array_mut_u16x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u16]) -> Self {
        simd.load_array_ref_u16x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u16]) {
        self.simd
            .store_array_u16x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u16) -> Self {
        simd.splat_u16x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_u16x8(block, block);
        block2.simd.combine_u16x16(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u16) -> Self {
        simd.load_array_u16x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u16x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u16x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdSplit<S> for u16x32<S> {
    type Split = u16x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u16x32(self)
    }
}
#[doc = "A SIMD mask of 32 16-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct mask16x32<S: Simd> {
    pub(crate) val: S::mask16x32,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i16; 32], S> for mask16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i16; 32]) -> Self {
        simd.load_array_mask16x32(val)
    }
}
impl<S: Simd> From<mask16x32<S>> for [i16; 32] {
    #[inline(always)]
    fn from(value: mask16x32<S>) -> Self {
        value.simd.as_array_mask16x32(value)
    }
}
impl<S: Simd> core::ops::Deref for mask16x32<S> {
    type Target = [i16; 32];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask16x32(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask16x32<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask16x32(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask16x32<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask16x32",
            &self.simd,
            self.simd.as_array_ref_mask16x32(self),
        )
    }
}
impl<S: Simd> SimdFrom<i16, S> for mask16x32<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i16) -> Self {
        simd.splat_mask16x32(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask16x32<S> {
    type Output = i16;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask16x32(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask16x32<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask16x32(self)[i]
    }
}
impl<S: Simd> Select<mask16x32<S>> for mask16x32<S> {
    #[inline(always)]
    fn select(self, if_true: mask16x32<S>, if_false: mask16x32<S>) -> mask16x32<S> {
        self.simd.select_mask16x32(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask16x32<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask16x32(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask16x32(value)
    }
}
impl<S: Simd> SimdBase<S> for mask16x32<S> {
    type Element = i16;
    const N: usize = 32;
    type Mask = mask16x32<S>;
    type Block = mask16x8<S>;
    type Array = [i16; 32];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i16] {
        self.simd.as_array_ref_mask16x32(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i16] {
        self.simd.as_array_mut_mask16x32(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i16]) -> Self {
        simd.load_array_ref_mask16x32(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i16]) {
        self.simd
            .store_array_mask16x32(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i16) -> Self {
        simd.splat_mask16x32(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_mask16x8(block, block);
        block2.simd.combine_mask16x16(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i16) -> Self {
        simd.load_array_mask16x32(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask16x32::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask16x32<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask16x32(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask16x32(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask16x32(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask16x32(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask16x32(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask16x32<S> {
    type Split = mask16x16<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask16x32(self)
    }
}
#[doc = "A SIMD vector of 16 [`i32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, i32x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = i32x16::splat(simd, 1);\n    let b = i32x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = i32x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = i32x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = i32x16::from_fn(simd, |i| i as i32);\n    # use fearless_simd::i32x4;\n    // From `Self::Block`:\n    let f = i32x16::block_splat(i32x4::simd_from(simd, [1, 2, 3, 4]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct i32x16<S: Simd> {
    pub(crate) val: S::i32x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 16], S> for i32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 16]) -> Self {
        simd.load_array_i32x16(val)
    }
}
impl<S: Simd> From<i32x16<S>> for [i32; 16] {
    #[inline(always)]
    fn from(value: i32x16<S>) -> Self {
        value.simd.as_array_i32x16(value)
    }
}
impl<S: Simd> core::ops::Deref for i32x16<S> {
    type Target = [i32; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_i32x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for i32x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_i32x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for i32x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "i32x16",
            &self.simd,
            self.simd.as_array_ref_i32x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<i32, S> for i32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_i32x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for i32x16<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_i32x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for i32x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_i32x16(self)[i]
    }
}
impl<S: Simd> Select<i32x16<S>> for mask32x16<S> {
    #[inline(always)]
    fn select(self, if_true: i32x16<S>, if_false: i32x16<S>) -> i32x16<S> {
        self.simd.select_i32x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for i32x16<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_i32x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_i32x16(value)
    }
}
impl<S: Simd> SimdBase<S> for i32x16<S> {
    type Element = i32;
    const N: usize = 16;
    type Mask = mask32x16<S>;
    type Block = i32x4<S>;
    type Array = [i32; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_i32x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_i32x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_i32x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_i32x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_i32x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_i32x4(block, block);
        block2.simd.combine_i32x8(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_i32x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_i32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_i32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for i32x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_i32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_i32x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x16<S>> for i32x16<S> {
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    #[inline(always)]
    fn truncate_from(x: f32x16<S>) -> Self {
        x.simd.cvt_i32_f32x16(x)
    }
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x16<S>) -> Self {
        x.simd.cvt_i32_precise_f32x16(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for i32x16<S> {
    type Split = i32x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_i32x16(self)
    }
}
#[doc = "A SIMD vector of 16 [`u32`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, u32x16};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = u32x16::splat(simd, 1);\n    let b = u32x16::simd_from(simd, 1);\n\n    // From a slice:\n    let c = u32x16::from_slice(simd, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an array:\n    let d = u32x16::simd_from(simd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n\n    // From an element-wise function:\n    let e = u32x16::from_fn(simd, |i| i as u32);\n    # use fearless_simd::u32x4;\n    // From `Self::Block`:\n    let f = u32x16::block_splat(u32x4::simd_from(simd, [1, 2, 3, 4]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct u32x16<S: Simd> {
    pub(crate) val: S::u32x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[u32; 16], S> for u32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [u32; 16]) -> Self {
        simd.load_array_u32x16(val)
    }
}
impl<S: Simd> From<u32x16<S>> for [u32; 16] {
    #[inline(always)]
    fn from(value: u32x16<S>) -> Self {
        value.simd.as_array_u32x16(value)
    }
}
impl<S: Simd> core::ops::Deref for u32x16<S> {
    type Target = [u32; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_u32x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for u32x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_u32x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for u32x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "u32x16",
            &self.simd,
            self.simd.as_array_ref_u32x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<u32, S> for u32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: u32) -> Self {
        simd.splat_u32x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for u32x16<S> {
    type Output = u32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_u32x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for u32x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_u32x16(self)[i]
    }
}
impl<S: Simd> Select<u32x16<S>> for mask32x16<S> {
    #[inline(always)]
    fn select(self, if_true: u32x16<S>, if_false: u32x16<S>) -> u32x16<S> {
        self.simd.select_u32x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for u32x16<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_u32x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_u32x16(value)
    }
}
impl<S: Simd> SimdBase<S> for u32x16<S> {
    type Element = u32;
    const N: usize = 16;
    type Mask = mask32x16<S>;
    type Block = u32x4<S>;
    type Array = [u32; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[u32] {
        self.simd.as_array_ref_u32x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [u32] {
        self.simd.as_array_mut_u32x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[u32]) -> Self {
        simd.load_array_ref_u32x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [u32]) {
        self.simd
            .store_array_u32x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: u32) -> Self {
        simd.splat_u32x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_u32x4(block, block);
        block2.simd.combine_u32x8(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> u32) -> Self {
        simd.load_array_u32x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_u32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_u32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdInt<S> for u32x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_u32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_u32x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> SimdCvtTruncate<f32x16<S>> for u32x16<S> {
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    #[inline(always)]
    fn truncate_from(x: f32x16<S>) -> Self {
        x.simd.cvt_u32_f32x16(x)
    }
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    #[inline(always)]
    fn truncate_from_precise(x: f32x16<S>) -> Self {
        x.simd.cvt_u32_precise_f32x16(x)
    }
}
impl<S: Simd> crate::SimdSplit<S> for u32x16<S> {
    type Split = u32x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_u32x16(self)
    }
}
#[doc = "A SIMD mask of 16 32-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct mask32x16<S: Simd> {
    pub(crate) val: S::mask32x16,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i32; 16], S> for mask32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i32; 16]) -> Self {
        simd.load_array_mask32x16(val)
    }
}
impl<S: Simd> From<mask32x16<S>> for [i32; 16] {
    #[inline(always)]
    fn from(value: mask32x16<S>) -> Self {
        value.simd.as_array_mask32x16(value)
    }
}
impl<S: Simd> core::ops::Deref for mask32x16<S> {
    type Target = [i32; 16];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask32x16(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask32x16<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask32x16(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask32x16<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask32x16",
            &self.simd,
            self.simd.as_array_ref_mask32x16(self),
        )
    }
}
impl<S: Simd> SimdFrom<i32, S> for mask32x16<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i32) -> Self {
        simd.splat_mask32x16(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask32x16<S> {
    type Output = i32;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask32x16(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask32x16<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask32x16(self)[i]
    }
}
impl<S: Simd> Select<mask32x16<S>> for mask32x16<S> {
    #[inline(always)]
    fn select(self, if_true: mask32x16<S>, if_false: mask32x16<S>) -> mask32x16<S> {
        self.simd.select_mask32x16(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask32x16<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask32x16(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask32x16(value)
    }
}
impl<S: Simd> SimdBase<S> for mask32x16<S> {
    type Element = i32;
    const N: usize = 16;
    type Mask = mask32x16<S>;
    type Block = mask32x4<S>;
    type Array = [i32; 16];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i32] {
        self.simd.as_array_ref_mask32x16(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i32] {
        self.simd.as_array_mut_mask32x16(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i32]) -> Self {
        simd.load_array_ref_mask32x16(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i32]) {
        self.simd
            .store_array_mask32x16(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i32) -> Self {
        simd.splat_mask32x16(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_mask32x4(block, block);
        block2.simd.combine_mask32x8(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i32) -> Self {
        simd.load_array_mask32x16(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask32x16::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask32x16<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask32x16(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask32x16(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask32x16(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask32x16(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask32x16(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask32x16<S> {
    type Split = mask32x8<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask32x16(self)
    }
}
#[doc = "A SIMD vector of 8 [`f64`] elements.\n\nYou may construct this vector type using the [`Self::splat`], [`Self::from_slice`], [`Self::simd_from`], [`Self::from_fn`], and [`Self::block_splat`] methods.\n\n```rust\n# use fearless_simd::{prelude::*, f64x8};\nfn construct_simd<S: Simd>(simd: S) {\n    // From a single scalar value:\n    let a = f64x8::splat(simd, 1.0);\n    let b = f64x8::simd_from(simd, 1.0);\n\n    // From a slice:\n    let c = f64x8::from_slice(simd, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);\n\n    // From an array:\n    let d = f64x8::simd_from(simd, [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);\n\n    // From an element-wise function:\n    let e = f64x8::from_fn(simd, |i| i as f64);\n    # use fearless_simd::f64x2;\n    // From `Self::Block`:\n    let f = f64x8::block_splat(f64x2::simd_from(simd, [1.0, 2.0]));\n}\n```"]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct f64x8<S: Simd> {
    pub(crate) val: S::f64x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[f64; 8], S> for f64x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [f64; 8]) -> Self {
        simd.load_array_f64x8(val)
    }
}
impl<S: Simd> From<f64x8<S>> for [f64; 8] {
    #[inline(always)]
    fn from(value: f64x8<S>) -> Self {
        value.simd.as_array_f64x8(value)
    }
}
impl<S: Simd> core::ops::Deref for f64x8<S> {
    type Target = [f64; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_f64x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for f64x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_f64x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for f64x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(f, "f64x8", &self.simd, self.simd.as_array_ref_f64x8(self))
    }
}
impl<S: Simd> SimdFrom<f64, S> for f64x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: f64) -> Self {
        simd.splat_f64x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for f64x8<S> {
    type Output = f64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_f64x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for f64x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_f64x8(self)[i]
    }
}
impl<S: Simd> Select<f64x8<S>> for mask64x8<S> {
    #[inline(always)]
    fn select(self, if_true: f64x8<S>, if_false: f64x8<S>) -> f64x8<S> {
        self.simd.select_f64x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for f64x8<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_f64x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_f64x8(value)
    }
}
impl<S: Simd> SimdBase<S> for f64x8<S> {
    type Element = f64;
    const N: usize = 8;
    type Mask = mask64x8<S>;
    type Block = f64x2<S>;
    type Array = [f64; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[f64] {
        self.simd.as_array_ref_f64x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [f64] {
        self.simd.as_array_mut_f64x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[f64]) -> Self {
        simd.load_array_ref_f64x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [f64]) {
        self.simd
            .store_array_f64x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: f64) -> Self {
        simd.splat_f64x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_f64x2(block, block);
        block2.simd.combine_f64x4(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> f64) -> Self {
        simd.load_array_f64x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_f64x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_f64x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdFloat<S> for f64x8<S> {
    #[inline(always)]
    fn abs(self) -> Self {
        self.simd.abs_f64x8(self)
    }
    #[inline(always)]
    fn sqrt(self) -> Self {
        self.simd.sqrt_f64x8(self)
    }
    #[inline(always)]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.copysign_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_lt_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_le_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_ge_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_gt_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_low_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.zip_high_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_low_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.unzip_high_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.max_precise_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd.min_precise_f64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_add_f64x8(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self {
        self.simd
            .mul_sub_f64x8(self, op1.simd_into(self.simd), op2.simd_into(self.simd))
    }
    #[inline(always)]
    fn floor(self) -> Self {
        self.simd.floor_f64x8(self)
    }
    #[inline(always)]
    fn ceil(self) -> Self {
        self.simd.ceil_f64x8(self)
    }
    #[inline(always)]
    fn round_ties_even(self) -> Self {
        self.simd.round_ties_even_f64x8(self)
    }
    #[inline(always)]
    fn fract(self) -> Self {
        self.simd.fract_f64x8(self)
    }
    #[inline(always)]
    fn trunc(self) -> Self {
        self.simd.trunc_f64x8(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for f64x8<S> {
    type Split = f64x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_f64x8(self)
    }
}
#[doc = "A SIMD mask of 8 64-bit elements.\n\nWhen created from a comparison operation, and as it should be used in a [`Self::select`] operation, each element will be all ones if it's \"true\", and all zeroes if it's \"false\"."]
#[derive(Clone, Copy)]
#[repr(C, align(64))]
pub struct mask64x8<S: Simd> {
    pub(crate) val: S::mask64x8,
    pub simd: S,
}
impl<S: Simd> SimdFrom<[i64; 8], S> for mask64x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, val: [i64; 8]) -> Self {
        simd.load_array_mask64x8(val)
    }
}
impl<S: Simd> From<mask64x8<S>> for [i64; 8] {
    #[inline(always)]
    fn from(value: mask64x8<S>) -> Self {
        value.simd.as_array_mask64x8(value)
    }
}
impl<S: Simd> core::ops::Deref for mask64x8<S> {
    type Target = [i64; 8];
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        self.simd.as_array_ref_mask64x8(self)
    }
}
impl<S: Simd> core::ops::DerefMut for mask64x8<S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.simd.as_array_mut_mask64x8(self)
    }
}
impl<S: Simd + core::fmt::Debug> core::fmt::Debug for mask64x8<S> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        crate::support::simd_debug_impl(
            f,
            "mask64x8",
            &self.simd,
            self.simd.as_array_ref_mask64x8(self),
        )
    }
}
impl<S: Simd> SimdFrom<i64, S> for mask64x8<S> {
    #[inline(always)]
    fn simd_from(simd: S, value: i64) -> Self {
        simd.splat_mask64x8(value)
    }
}
impl<S: Simd> core::ops::Index<usize> for mask64x8<S> {
    type Output = i64;
    #[inline(always)]
    fn index(&self, i: usize) -> &Self::Output {
        &self.simd.as_array_ref_mask64x8(self)[i]
    }
}
impl<S: Simd> core::ops::IndexMut<usize> for mask64x8<S> {
    #[inline(always)]
    fn index_mut(&mut self, i: usize) -> &mut Self::Output {
        &mut self.simd.as_array_mut_mask64x8(self)[i]
    }
}
impl<S: Simd> Select<mask64x8<S>> for mask64x8<S> {
    #[inline(always)]
    fn select(self, if_true: mask64x8<S>, if_false: mask64x8<S>) -> mask64x8<S> {
        self.simd.select_mask64x8(self, if_true, if_false)
    }
}
impl<S: Simd> Bytes for mask64x8<S> {
    type Bytes = u8x64<S>;
    #[inline(always)]
    fn to_bytes(self) -> Self::Bytes {
        self.simd.cvt_to_bytes_mask64x8(self)
    }
    #[inline(always)]
    fn from_bytes(value: Self::Bytes) -> Self {
        value.simd.cvt_from_bytes_mask64x8(value)
    }
}
impl<S: Simd> SimdBase<S> for mask64x8<S> {
    type Element = i64;
    const N: usize = 8;
    type Mask = mask64x8<S>;
    type Block = mask64x2<S>;
    type Array = [i64; 8];
    #[inline(always)]
    fn witness(&self) -> S {
        self.simd
    }
    #[inline(always)]
    fn as_slice(&self) -> &[i64] {
        self.simd.as_array_ref_mask64x8(self).as_slice()
    }
    #[inline(always)]
    fn as_mut_slice(&mut self) -> &mut [i64] {
        self.simd.as_array_mut_mask64x8(self).as_mut_slice()
    }
    #[inline(always)]
    fn from_slice(simd: S, slice: &[i64]) -> Self {
        simd.load_array_ref_mask64x8(slice.try_into().unwrap())
    }
    #[inline(always)]
    fn store_slice(&self, slice: &mut [i64]) {
        self.simd
            .store_array_mask64x8(*self, slice.try_into().unwrap());
    }
    #[inline(always)]
    fn splat(simd: S, val: i64) -> Self {
        simd.splat_mask64x8(val)
    }
    #[inline(always)]
    fn block_splat(block: Self::Block) -> Self {
        let block2 = block.simd.combine_mask64x2(block, block);
        block2.simd.combine_mask64x4(block2, block2)
    }
    #[inline(always)]
    fn from_fn(simd: S, f: impl FnMut(usize) -> i64) -> Self {
        simd.load_array_mask64x8(core::array::from_fn(f))
    }
    #[inline(always)]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_mask64x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self {
        self.simd
            .slide_within_blocks_mask64x8::<SHIFT>(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> crate::SimdMask<S> for mask64x8<S> {
    #[inline(always)]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask {
        self.simd.simd_eq_mask64x8(self, rhs.simd_into(self.simd))
    }
    #[inline(always)]
    fn any_true(self) -> bool {
        self.simd.any_true_mask64x8(self)
    }
    #[inline(always)]
    fn all_true(self) -> bool {
        self.simd.all_true_mask64x8(self)
    }
    #[inline(always)]
    fn any_false(self) -> bool {
        self.simd.any_false_mask64x8(self)
    }
    #[inline(always)]
    fn all_false(self) -> bool {
        self.simd.all_false_mask64x8(self)
    }
}
impl<S: Simd> crate::SimdSplit<S> for mask64x8<S> {
    type Split = mask64x4<S>;
    #[inline(always)]
    fn split(self) -> (Self::Split, Self::Split) {
        self.simd.split_mask64x8(self)
    }
}
