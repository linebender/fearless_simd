// Copyright 2025 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

// This file is autogenerated by fearless_simd_gen

use crate::{
    Bytes, Level, Select, SimdCvtFloat, SimdCvtTruncate, SimdElement, SimdFrom, SimdInto,
    seal::Seal,
};
use crate::{
    f32x4, f32x8, f32x16, f64x2, f64x4, f64x8, i8x16, i8x32, i8x64, i16x8, i16x16, i16x32, i32x4,
    i32x8, i32x16, mask8x16, mask8x32, mask8x64, mask16x8, mask16x16, mask16x32, mask32x4,
    mask32x8, mask32x16, mask64x2, mask64x4, mask64x8, u8x16, u8x32, u8x64, u16x8, u16x16, u16x32,
    u32x4, u32x8, u32x16,
};
#[doc = r" The main SIMD trait, implemented by all SIMD token types."]
#[doc = r""]
#[doc = r#" Each implementor of this trait (e.g. `Avx2`, `Sse4_2`, `Neon`, `Fallback`) is a zero-sized "token" type"#]
#[doc = r" representing a specific SIMD instruction set. These tokens are obtained at runtime via [`Level`] and the"]
#[doc = r" [`dispatch!`](crate::dispatch) macro, which selects the best available backend for the current CPU."]
#[doc = r""]
#[doc = r" This trait defines all the low-level SIMD operations (e.g. [`add_f32x4`](Simd::add_f32x4),"]
#[doc = r" [`mul_u32x4`](Simd::mul_u32x4)) that are implemented by each token type using platform-specific intrinsics."]
#[doc = r" However, you typically won't call these methods directly. Instead, you'll probably be using the methods"]
#[doc = r" defined on the vector types themselves."]
#[doc = r""]
#[doc = r" # Associated Types"]
#[doc = r""]
#[doc = r#" The trait defines associated types for the highest "native" vector width of each scalar type (e.g. `f32s`,"#]
#[doc = r" `u32s`). These are always at least 128 bits, but may be larger. Currently, they are 128 bits everywhere but"]
#[doc = r" AVX2, where they are 256 bits."]
#[doc = r""]
#[doc = r" # Example"]
#[doc = r""]
#[doc = r" ```"]
#[doc = r" # use fearless_simd::{prelude::*, f32x4, dispatch, Level};"]
#[doc = r""]
#[doc = r" #[inline(always)]"]
#[doc = r" fn add_vectors<S: Simd>(simd: S, a: f32x4<S>, b: f32x4<S>) -> f32x4<S> {"]
#[doc = r"     a + b  // Uses operator overloading, which calls simd.add_f32x4 internally"]
#[doc = r" }"]
#[doc = r""]
#[doc = r" let level = Level::new();"]
#[doc = r" dispatch!(level, simd => {"]
#[doc = r"     let a = [1.0, 2.0, 3.0, 4.0].simd_into(simd);"]
#[doc = r"     let b = [5.0, 6.0, 7.0, 8.0].simd_into(simd);"]
#[doc = r"     let result = add_vectors(simd, a, b);"]
#[doc = r"     # assert_eq!(*result, [6.0, 8.0, 10.0, 12.0]);"]
#[doc = r" });"]
#[doc = r" ```"]
pub trait Simd:
    Sized + Clone + Copy + Send + Sync + Seal + arch_types::ArchTypes + 'static
{
    #[doc = r" A native-width SIMD vector of [`f32`]s."]
    type f32s: SimdFloat<
            Self,
            Element = f32,
            Block = f32x4<Self>,
            Mask = Self::mask32s,
            Bytes = <Self::u32s as Bytes>::Bytes,
        > + SimdCvtFloat<Self::u32s>
        + SimdCvtFloat<Self::i32s>;
    #[doc = r" A native-width SIMD vector of [`f64`]s."]
    type f64s: SimdFloat<Self, Element = f64, Block = f64x2<Self>, Mask = Self::mask64s>;
    #[doc = r" A native-width SIMD vector of [`u8`]s."]
    type u8s: SimdInt<Self, Element = u8, Block = u8x16<Self>, Mask = Self::mask8s>;
    #[doc = r" A native-width SIMD vector of [`i8`]s."]
    type i8s: SimdInt<
            Self,
            Element = i8,
            Block = i8x16<Self>,
            Mask = Self::mask8s,
            Bytes = <Self::u8s as Bytes>::Bytes,
        > + core::ops::Neg<Output = Self::i8s>;
    #[doc = r" A native-width SIMD vector of [`u16`]s."]
    type u16s: SimdInt<Self, Element = u16, Block = u16x8<Self>, Mask = Self::mask16s>;
    #[doc = r" A native-width SIMD vector of [`i16`]s."]
    type i16s: SimdInt<
            Self,
            Element = i16,
            Block = i16x8<Self>,
            Mask = Self::mask16s,
            Bytes = <Self::u16s as Bytes>::Bytes,
        > + core::ops::Neg<Output = Self::i16s>;
    #[doc = r" A native-width SIMD vector of [`u32`]s."]
    type u32s: SimdInt<Self, Element = u32, Block = u32x4<Self>, Mask = Self::mask32s>
        + SimdCvtTruncate<Self::f32s>;
    #[doc = r" A native-width SIMD vector of [`i32`]s."]
    type i32s: SimdInt<
            Self,
            Element = i32,
            Block = i32x4<Self>,
            Mask = Self::mask32s,
            Bytes = <Self::u32s as Bytes>::Bytes,
        > + SimdCvtTruncate<Self::f32s>
        + core::ops::Neg<Output = Self::i32s>;
    #[doc = r" A native-width SIMD mask with 8-bit lanes."]
    type mask8s: SimdMask<Self, Element = i8, Block = mask8x16<Self>, Bytes = <Self::u8s as Bytes>::Bytes>
        + Select<Self::u8s>
        + Select<Self::i8s>
        + Select<Self::mask8s>;
    #[doc = r" A native-width SIMD mask with 16-bit lanes."]
    type mask16s: SimdMask<Self, Element = i16, Block = mask16x8<Self>, Bytes = <Self::u16s as Bytes>::Bytes>
        + Select<Self::u16s>
        + Select<Self::i16s>
        + Select<Self::mask16s>;
    #[doc = r" A native-width SIMD mask with 32-bit lanes."]
    type mask32s: SimdMask<Self, Element = i32, Block = mask32x4<Self>, Bytes = <Self::u32s as Bytes>::Bytes>
        + Select<Self::f32s>
        + Select<Self::u32s>
        + Select<Self::i32s>
        + Select<Self::mask32s>;
    #[doc = r" A native-width SIMD mask with 64-bit lanes."]
    type mask64s: SimdMask<Self, Element = i64, Block = mask64x2<Self>>
        + Select<Self::f64s>
        + Select<Self::mask64s>;
    #[doc = r" This SIMD token's feature level."]
    fn level(self) -> Level;
    #[doc = r" Call function with CPU features enabled."]
    #[doc = r""]
    #[doc = r" For performance, the provided function should be `#[inline(always)]`."]
    fn vectorize<F: FnOnce() -> R, R>(self, f: F) -> R;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f32x4(self, val: f32) -> f32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f32x4(self, val: [f32; 4usize]) -> f32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f32x4(self, val: &[f32; 4usize]) -> f32x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f32x4(self, a: f32x4<Self>) -> [f32; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f32x4(self, a: &f32x4<Self>) -> &[f32; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f32x4(self, a: &mut f32x4<Self>) -> &mut [f32; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f32x4(self, a: f32x4<Self>, dest: &mut [f32; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f32x4(self, a: u8x16<Self>) -> f32x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f32x4(self, a: f32x4<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f32x4<const SHIFT: usize>(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f32x4<const SHIFT: usize>(
        self,
        a: f32x4<Self>,
        b: f32x4<Self>,
    ) -> f32x4<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> mask32x4<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f32x4(self, a: f32x4<Self>, b: f32x4<Self>, c: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f32x4(self, a: f32x4<Self>, b: f32x4<Self>, c: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f32x4(self, a: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f32x4(self, a: mask32x4<Self>, b: f32x4<Self>, c: f32x4<Self>) -> f32x4<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_f32x4(self, a: f32x4<Self>, b: f32x4<Self>) -> f32x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `f64` elements.\n\nThe number of elements in the result is half that of the input."]
    fn reinterpret_f64_f32x4(self, a: f32x4<Self>) -> f64x2<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `i32` elements.\n\nThis is a bitwise reinterpretation only, and does not perform any conversions."]
    fn reinterpret_i32_f32x4(self, a: f32x4<Self>) -> i32x4<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_f32x4(self, a: f32x4<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_f32x4(self, a: f32x4<Self>) -> u32x4<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    fn cvt_u32_f32x4(self, a: f32x4<Self>) -> u32x4<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_u32_precise_f32x4(self, a: f32x4<Self>) -> u32x4<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    fn cvt_i32_f32x4(self, a: f32x4<Self>) -> i32x4<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_i32_precise_f32x4(self, a: f32x4<Self>) -> i32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i8x16(self, val: i8) -> i8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i8x16(self, val: [i8; 16usize]) -> i8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i8x16(self, val: &[i8; 16usize]) -> i8x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i8x16(self, a: i8x16<Self>) -> [i8; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i8x16(self, a: &i8x16<Self>) -> &[i8; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i8x16(self, a: &mut i8x16<Self>) -> &mut [i8; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i8x16(self, a: i8x16<Self>, dest: &mut [i8; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i8x16(self, a: u8x16<Self>) -> i8x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i8x16(self, a: i8x16<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i8x16<const SHIFT: usize>(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i8x16<const SHIFT: usize>(
        self,
        a: i8x16<Self>,
        b: i8x16<Self>,
    ) -> i8x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i8x16(self, a: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i8x16(self, a: i8x16<Self>, shift: u32) -> i8x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i8x16(self, a: i8x16<Self>, shift: u32) -> i8x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> mask8x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i8x16(self, a: mask8x16<Self>, b: i8x16<Self>, c: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i8x16(self, a: i8x16<Self>, b: i8x16<Self>) -> i8x32<Self>;
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i8x16(self, a: i8x16<Self>) -> i8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i8x16(self, a: i8x16<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i8x16(self, a: i8x16<Self>) -> u32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u8x16(self, val: u8) -> u8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u8x16(self, val: [u8; 16usize]) -> u8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u8x16(self, val: &[u8; 16usize]) -> u8x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u8x16(self, a: u8x16<Self>) -> [u8; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u8x16(self, a: &u8x16<Self>) -> &[u8; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u8x16(self, a: &mut u8x16<Self>) -> &mut [u8; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u8x16(self, a: u8x16<Self>, dest: &mut [u8; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u8x16(self, a: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u8x16(self, a: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u8x16<const SHIFT: usize>(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u8x16<const SHIFT: usize>(
        self,
        a: u8x16<Self>,
        b: u8x16<Self>,
    ) -> u8x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u8x16(self, a: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u8x16(self, a: u8x16<Self>, shift: u32) -> u8x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u8x16(self, a: u8x16<Self>, shift: u32) -> u8x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u8x16(self, a: mask8x16<Self>, b: u8x16<Self>, c: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x16<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u8x16(self, a: u8x16<Self>, b: u8x16<Self>) -> u8x32<Self>;
    #[doc = "Zero-extend each element to a wider integer type.\n\nThe number of elements in the result is half that of the input."]
    fn widen_u8x16(self, a: u8x16<Self>) -> u16x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u8x16(self, a: u8x16<Self>) -> u32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask8x16(self, val: i8) -> mask8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask8x16(self, val: [i8; 16usize]) -> mask8x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask8x16(self, val: &[i8; 16usize]) -> mask8x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask8x16(self, a: mask8x16<Self>) -> [i8; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask8x16(self, a: &mask8x16<Self>) -> &[i8; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask8x16(self, a: &mut mask8x16<Self>) -> &mut [i8; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask8x16(self, a: mask8x16<Self>, dest: &mut [i8; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask8x16(self, a: u8x16<Self>) -> mask8x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask8x16(self, a: mask8x16<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask8x16<const SHIFT: usize>(
        self,
        a: mask8x16<Self>,
        b: mask8x16<Self>,
    ) -> mask8x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask8x16<const SHIFT: usize>(
        self,
        a: mask8x16<Self>,
        b: mask8x16<Self>,
    ) -> mask8x16<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask8x16(self, a: mask8x16<Self>, b: mask8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask8x16(self, a: mask8x16<Self>, b: mask8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask8x16(self, a: mask8x16<Self>, b: mask8x16<Self>) -> mask8x16<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask8x16(self, a: mask8x16<Self>) -> mask8x16<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask8x16(
        self,
        a: mask8x16<Self>,
        b: mask8x16<Self>,
        c: mask8x16<Self>,
    ) -> mask8x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask8x16(self, a: mask8x16<Self>, b: mask8x16<Self>) -> mask8x16<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask8x16(self, a: mask8x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask8x16(self, a: mask8x16<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask8x16(self, a: mask8x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask8x16(self, a: mask8x16<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask8x16(self, a: mask8x16<Self>, b: mask8x16<Self>) -> mask8x32<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i16x8(self, val: i16) -> i16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i16x8(self, val: [i16; 8usize]) -> i16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i16x8(self, val: &[i16; 8usize]) -> i16x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i16x8(self, a: i16x8<Self>) -> [i16; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i16x8(self, a: &i16x8<Self>) -> &[i16; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i16x8(self, a: &mut i16x8<Self>) -> &mut [i16; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i16x8(self, a: i16x8<Self>, dest: &mut [i16; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i16x8(self, a: u8x16<Self>) -> i16x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i16x8(self, a: i16x8<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i16x8<const SHIFT: usize>(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i16x8<const SHIFT: usize>(
        self,
        a: i16x8<Self>,
        b: i16x8<Self>,
    ) -> i16x8<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i16x8(self, a: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i16x8(self, a: i16x8<Self>, shift: u32) -> i16x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i16x8(self, a: i16x8<Self>, shift: u32) -> i16x8<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> mask16x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i16x8(self, a: mask16x8<Self>, b: i16x8<Self>, c: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i16x8(self, a: i16x8<Self>, b: i16x8<Self>) -> i16x16<Self>;
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i16x8(self, a: i16x8<Self>) -> i16x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i16x8(self, a: i16x8<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i16x8(self, a: i16x8<Self>) -> u32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u16x8(self, val: u16) -> u16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u16x8(self, val: [u16; 8usize]) -> u16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u16x8(self, val: &[u16; 8usize]) -> u16x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u16x8(self, a: u16x8<Self>) -> [u16; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u16x8(self, a: &u16x8<Self>) -> &[u16; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u16x8(self, a: &mut u16x8<Self>) -> &mut [u16; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u16x8(self, a: u16x8<Self>, dest: &mut [u16; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u16x8(self, a: u8x16<Self>) -> u16x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u16x8(self, a: u16x8<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u16x8<const SHIFT: usize>(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u16x8<const SHIFT: usize>(
        self,
        a: u16x8<Self>,
        b: u16x8<Self>,
    ) -> u16x8<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u16x8(self, a: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u16x8(self, a: u16x8<Self>, shift: u32) -> u16x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u16x8(self, a: u16x8<Self>, shift: u32) -> u16x8<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> mask16x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u16x8(self, a: mask16x8<Self>, b: u16x8<Self>, c: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x8<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u16x8(self, a: u16x8<Self>, b: u16x8<Self>) -> u16x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u16x8(self, a: u16x8<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u16x8(self, a: u16x8<Self>) -> u32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask16x8(self, val: i16) -> mask16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask16x8(self, val: [i16; 8usize]) -> mask16x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask16x8(self, val: &[i16; 8usize]) -> mask16x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask16x8(self, a: mask16x8<Self>) -> [i16; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask16x8(self, a: &mask16x8<Self>) -> &[i16; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask16x8(self, a: &mut mask16x8<Self>) -> &mut [i16; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask16x8(self, a: mask16x8<Self>, dest: &mut [i16; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask16x8(self, a: u8x16<Self>) -> mask16x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask16x8(self, a: mask16x8<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask16x8<const SHIFT: usize>(
        self,
        a: mask16x8<Self>,
        b: mask16x8<Self>,
    ) -> mask16x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask16x8<const SHIFT: usize>(
        self,
        a: mask16x8<Self>,
        b: mask16x8<Self>,
    ) -> mask16x8<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask16x8(self, a: mask16x8<Self>, b: mask16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask16x8(self, a: mask16x8<Self>, b: mask16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask16x8(self, a: mask16x8<Self>, b: mask16x8<Self>) -> mask16x8<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask16x8(self, a: mask16x8<Self>) -> mask16x8<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask16x8(
        self,
        a: mask16x8<Self>,
        b: mask16x8<Self>,
        c: mask16x8<Self>,
    ) -> mask16x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask16x8(self, a: mask16x8<Self>, b: mask16x8<Self>) -> mask16x8<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask16x8(self, a: mask16x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask16x8(self, a: mask16x8<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask16x8(self, a: mask16x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask16x8(self, a: mask16x8<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask16x8(self, a: mask16x8<Self>, b: mask16x8<Self>) -> mask16x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i32x4(self, val: i32) -> i32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i32x4(self, val: [i32; 4usize]) -> i32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i32x4(self, val: &[i32; 4usize]) -> i32x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i32x4(self, a: i32x4<Self>) -> [i32; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i32x4(self, a: &i32x4<Self>) -> &[i32; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i32x4(self, a: &mut i32x4<Self>) -> &mut [i32; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i32x4(self, a: i32x4<Self>, dest: &mut [i32; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i32x4(self, a: u8x16<Self>) -> i32x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i32x4(self, a: i32x4<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i32x4<const SHIFT: usize>(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i32x4<const SHIFT: usize>(
        self,
        a: i32x4<Self>,
        b: i32x4<Self>,
    ) -> i32x4<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i32x4(self, a: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i32x4(self, a: i32x4<Self>, shift: u32) -> i32x4<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i32x4(self, a: i32x4<Self>, shift: u32) -> i32x4<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> mask32x4<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i32x4(self, a: mask32x4<Self>, b: i32x4<Self>, c: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i32x4(self, a: i32x4<Self>, b: i32x4<Self>) -> i32x8<Self>;
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i32x4(self, a: i32x4<Self>) -> i32x4<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i32x4(self, a: i32x4<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i32x4(self, a: i32x4<Self>) -> u32x4<Self>;
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_i32x4(self, a: i32x4<Self>) -> f32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u32x4(self, val: u32) -> u32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u32x4(self, val: [u32; 4usize]) -> u32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u32x4(self, val: &[u32; 4usize]) -> u32x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u32x4(self, a: u32x4<Self>) -> [u32; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u32x4(self, a: &u32x4<Self>) -> &[u32; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u32x4(self, a: &mut u32x4<Self>) -> &mut [u32; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u32x4(self, a: u32x4<Self>, dest: &mut [u32; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u32x4(self, a: u8x16<Self>) -> u32x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u32x4(self, a: u32x4<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u32x4<const SHIFT: usize>(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u32x4<const SHIFT: usize>(
        self,
        a: u32x4<Self>,
        b: u32x4<Self>,
    ) -> u32x4<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u32x4(self, a: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u32x4(self, a: u32x4<Self>, shift: u32) -> u32x4<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u32x4(self, a: u32x4<Self>, shift: u32) -> u32x4<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> mask32x4<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u32x4(self, a: mask32x4<Self>, b: u32x4<Self>, c: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x4<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u32x4(self, a: u32x4<Self>, b: u32x4<Self>) -> u32x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u32x4(self, a: u32x4<Self>) -> u8x16<Self>;
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_u32x4(self, a: u32x4<Self>) -> f32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask32x4(self, val: i32) -> mask32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask32x4(self, val: [i32; 4usize]) -> mask32x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask32x4(self, val: &[i32; 4usize]) -> mask32x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask32x4(self, a: mask32x4<Self>) -> [i32; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask32x4(self, a: &mask32x4<Self>) -> &[i32; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask32x4(self, a: &mut mask32x4<Self>) -> &mut [i32; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask32x4(self, a: mask32x4<Self>, dest: &mut [i32; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask32x4(self, a: u8x16<Self>) -> mask32x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask32x4(self, a: mask32x4<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask32x4<const SHIFT: usize>(
        self,
        a: mask32x4<Self>,
        b: mask32x4<Self>,
    ) -> mask32x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask32x4<const SHIFT: usize>(
        self,
        a: mask32x4<Self>,
        b: mask32x4<Self>,
    ) -> mask32x4<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask32x4(self, a: mask32x4<Self>, b: mask32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask32x4(self, a: mask32x4<Self>, b: mask32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask32x4(self, a: mask32x4<Self>, b: mask32x4<Self>) -> mask32x4<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask32x4(self, a: mask32x4<Self>) -> mask32x4<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask32x4(
        self,
        a: mask32x4<Self>,
        b: mask32x4<Self>,
        c: mask32x4<Self>,
    ) -> mask32x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask32x4(self, a: mask32x4<Self>, b: mask32x4<Self>) -> mask32x4<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask32x4(self, a: mask32x4<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask32x4(self, a: mask32x4<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask32x4(self, a: mask32x4<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask32x4(self, a: mask32x4<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask32x4(self, a: mask32x4<Self>, b: mask32x4<Self>) -> mask32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f64x2(self, val: f64) -> f64x2<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f64x2(self, val: [f64; 2usize]) -> f64x2<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f64x2(self, val: &[f64; 2usize]) -> f64x2<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f64x2(self, a: f64x2<Self>) -> [f64; 2usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f64x2(self, a: &f64x2<Self>) -> &[f64; 2usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f64x2(self, a: &mut f64x2<Self>) -> &mut [f64; 2usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f64x2(self, a: f64x2<Self>, dest: &mut [f64; 2usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f64x2(self, a: u8x16<Self>) -> f64x2<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f64x2(self, a: f64x2<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f64x2<const SHIFT: usize>(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f64x2<const SHIFT: usize>(
        self,
        a: f64x2<Self>,
        b: f64x2<Self>,
    ) -> f64x2<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> mask64x2<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f64x2(self, a: f64x2<Self>, b: f64x2<Self>, c: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f64x2(self, a: f64x2<Self>, b: f64x2<Self>, c: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f64x2(self, a: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f64x2(self, a: mask64x2<Self>, b: f64x2<Self>, c: f64x2<Self>) -> f64x2<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_f64x2(self, a: f64x2<Self>, b: f64x2<Self>) -> f64x4<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `f32` elements.\n\nThe number of elements in the result is twice that of the input."]
    fn reinterpret_f32_f64x2(self, a: f64x2<Self>) -> f32x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask64x2(self, val: i64) -> mask64x2<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask64x2(self, val: [i64; 2usize]) -> mask64x2<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask64x2(self, val: &[i64; 2usize]) -> mask64x2<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask64x2(self, a: mask64x2<Self>) -> [i64; 2usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask64x2(self, a: &mask64x2<Self>) -> &[i64; 2usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask64x2(self, a: &mut mask64x2<Self>) -> &mut [i64; 2usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask64x2(self, a: mask64x2<Self>, dest: &mut [i64; 2usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask64x2(self, a: u8x16<Self>) -> mask64x2<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask64x2(self, a: mask64x2<Self>) -> u8x16<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask64x2<const SHIFT: usize>(
        self,
        a: mask64x2<Self>,
        b: mask64x2<Self>,
    ) -> mask64x2<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask64x2<const SHIFT: usize>(
        self,
        a: mask64x2<Self>,
        b: mask64x2<Self>,
    ) -> mask64x2<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask64x2(self, a: mask64x2<Self>, b: mask64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask64x2(self, a: mask64x2<Self>, b: mask64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask64x2(self, a: mask64x2<Self>, b: mask64x2<Self>) -> mask64x2<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask64x2(self, a: mask64x2<Self>) -> mask64x2<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask64x2(
        self,
        a: mask64x2<Self>,
        b: mask64x2<Self>,
        c: mask64x2<Self>,
    ) -> mask64x2<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask64x2(self, a: mask64x2<Self>, b: mask64x2<Self>) -> mask64x2<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask64x2(self, a: mask64x2<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask64x2(self, a: mask64x2<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask64x2(self, a: mask64x2<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask64x2(self, a: mask64x2<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask64x2(self, a: mask64x2<Self>, b: mask64x2<Self>) -> mask64x4<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f32x8(self, val: f32) -> f32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f32x8(self, val: [f32; 8usize]) -> f32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f32x8(self, val: &[f32; 8usize]) -> f32x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f32x8(self, a: f32x8<Self>) -> [f32; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f32x8(self, a: &f32x8<Self>) -> &[f32; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f32x8(self, a: &mut f32x8<Self>) -> &mut [f32; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f32x8(self, a: f32x8<Self>, dest: &mut [f32; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f32x8(self, a: u8x32<Self>) -> f32x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f32x8(self, a: f32x8<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f32x8<const SHIFT: usize>(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f32x8<const SHIFT: usize>(
        self,
        a: f32x8<Self>,
        b: f32x8<Self>,
    ) -> f32x8<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> mask32x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f32x8(self, a: f32x8<Self>, b: f32x8<Self>, c: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f32x8(self, a: f32x8<Self>, b: f32x8<Self>, c: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f32x8(self, a: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f32x8(self, a: mask32x8<Self>, b: f32x8<Self>, c: f32x8<Self>) -> f32x8<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_f32x8(self, a: f32x8<Self>, b: f32x8<Self>) -> f32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_f32x8(self, a: f32x8<Self>) -> (f32x4<Self>, f32x4<Self>);
    #[doc = "Reinterpret the bits of this vector as a vector of `f64` elements.\n\nThe number of elements in the result is half that of the input."]
    fn reinterpret_f64_f32x8(self, a: f32x8<Self>) -> f64x4<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `i32` elements.\n\nThis is a bitwise reinterpretation only, and does not perform any conversions."]
    fn reinterpret_i32_f32x8(self, a: f32x8<Self>) -> i32x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_f32x8(self, a: f32x8<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_f32x8(self, a: f32x8<Self>) -> u32x8<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    fn cvt_u32_f32x8(self, a: f32x8<Self>) -> u32x8<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_u32_precise_f32x8(self, a: f32x8<Self>) -> u32x8<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    fn cvt_i32_f32x8(self, a: f32x8<Self>) -> i32x8<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_i32_precise_f32x8(self, a: f32x8<Self>) -> i32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i8x32(self, val: i8) -> i8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i8x32(self, val: [i8; 32usize]) -> i8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i8x32(self, val: &[i8; 32usize]) -> i8x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i8x32(self, a: i8x32<Self>) -> [i8; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i8x32(self, a: &i8x32<Self>) -> &[i8; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i8x32(self, a: &mut i8x32<Self>) -> &mut [i8; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i8x32(self, a: i8x32<Self>, dest: &mut [i8; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i8x32(self, a: u8x32<Self>) -> i8x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i8x32(self, a: i8x32<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i8x32<const SHIFT: usize>(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i8x32<const SHIFT: usize>(
        self,
        a: i8x32<Self>,
        b: i8x32<Self>,
    ) -> i8x32<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i8x32(self, a: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i8x32(self, a: i8x32<Self>, shift: u32) -> i8x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i8x32(self, a: i8x32<Self>, shift: u32) -> i8x32<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> mask8x32<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i8x32(self, a: mask8x32<Self>, b: i8x32<Self>, c: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i8x32(self, a: i8x32<Self>, b: i8x32<Self>) -> i8x64<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i8x32(self, a: i8x32<Self>) -> (i8x16<Self>, i8x16<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i8x32(self, a: i8x32<Self>) -> i8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i8x32(self, a: i8x32<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i8x32(self, a: i8x32<Self>) -> u32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u8x32(self, val: u8) -> u8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u8x32(self, val: [u8; 32usize]) -> u8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u8x32(self, val: &[u8; 32usize]) -> u8x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u8x32(self, a: u8x32<Self>) -> [u8; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u8x32(self, a: &u8x32<Self>) -> &[u8; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u8x32(self, a: &mut u8x32<Self>) -> &mut [u8; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u8x32(self, a: u8x32<Self>, dest: &mut [u8; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u8x32(self, a: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u8x32(self, a: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u8x32<const SHIFT: usize>(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u8x32<const SHIFT: usize>(
        self,
        a: u8x32<Self>,
        b: u8x32<Self>,
    ) -> u8x32<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u8x32(self, a: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u8x32(self, a: u8x32<Self>, shift: u32) -> u8x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u8x32(self, a: u8x32<Self>, shift: u32) -> u8x32<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u8x32(self, a: mask8x32<Self>, b: u8x32<Self>, c: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x32<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u8x32(self, a: u8x32<Self>, b: u8x32<Self>) -> u8x64<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u8x32(self, a: u8x32<Self>) -> (u8x16<Self>, u8x16<Self>);
    #[doc = "Zero-extend each element to a wider integer type.\n\nThe number of elements in the result is half that of the input."]
    fn widen_u8x32(self, a: u8x32<Self>) -> u16x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u8x32(self, a: u8x32<Self>) -> u32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask8x32(self, val: i8) -> mask8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask8x32(self, val: [i8; 32usize]) -> mask8x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask8x32(self, val: &[i8; 32usize]) -> mask8x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask8x32(self, a: mask8x32<Self>) -> [i8; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask8x32(self, a: &mask8x32<Self>) -> &[i8; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask8x32(self, a: &mut mask8x32<Self>) -> &mut [i8; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask8x32(self, a: mask8x32<Self>, dest: &mut [i8; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask8x32(self, a: u8x32<Self>) -> mask8x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask8x32(self, a: mask8x32<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask8x32<const SHIFT: usize>(
        self,
        a: mask8x32<Self>,
        b: mask8x32<Self>,
    ) -> mask8x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask8x32<const SHIFT: usize>(
        self,
        a: mask8x32<Self>,
        b: mask8x32<Self>,
    ) -> mask8x32<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask8x32(self, a: mask8x32<Self>, b: mask8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask8x32(self, a: mask8x32<Self>, b: mask8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask8x32(self, a: mask8x32<Self>, b: mask8x32<Self>) -> mask8x32<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask8x32(self, a: mask8x32<Self>) -> mask8x32<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask8x32(
        self,
        a: mask8x32<Self>,
        b: mask8x32<Self>,
        c: mask8x32<Self>,
    ) -> mask8x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask8x32(self, a: mask8x32<Self>, b: mask8x32<Self>) -> mask8x32<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask8x32(self, a: mask8x32<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask8x32(self, a: mask8x32<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask8x32(self, a: mask8x32<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask8x32(self, a: mask8x32<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask8x32(self, a: mask8x32<Self>, b: mask8x32<Self>) -> mask8x64<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask8x32(self, a: mask8x32<Self>) -> (mask8x16<Self>, mask8x16<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i16x16(self, val: i16) -> i16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i16x16(self, val: [i16; 16usize]) -> i16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i16x16(self, val: &[i16; 16usize]) -> i16x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i16x16(self, a: i16x16<Self>) -> [i16; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i16x16(self, a: &i16x16<Self>) -> &[i16; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i16x16(self, a: &mut i16x16<Self>) -> &mut [i16; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i16x16(self, a: i16x16<Self>, dest: &mut [i16; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i16x16(self, a: u8x32<Self>) -> i16x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i16x16(self, a: i16x16<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i16x16<const SHIFT: usize>(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i16x16<const SHIFT: usize>(
        self,
        a: i16x16<Self>,
        b: i16x16<Self>,
    ) -> i16x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i16x16(self, a: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i16x16(self, a: i16x16<Self>, shift: u32) -> i16x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i16x16(self, a: i16x16<Self>, shift: u32) -> i16x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> mask16x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i16x16(self, a: mask16x16<Self>, b: i16x16<Self>, c: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i16x16(self, a: i16x16<Self>, b: i16x16<Self>) -> i16x32<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i16x16(self, a: i16x16<Self>) -> (i16x8<Self>, i16x8<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i16x16(self, a: i16x16<Self>) -> i16x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i16x16(self, a: i16x16<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i16x16(self, a: i16x16<Self>) -> u32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u16x16(self, val: u16) -> u16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u16x16(self, val: [u16; 16usize]) -> u16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u16x16(self, val: &[u16; 16usize]) -> u16x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u16x16(self, a: u16x16<Self>) -> [u16; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u16x16(self, a: &u16x16<Self>) -> &[u16; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u16x16(self, a: &mut u16x16<Self>) -> &mut [u16; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u16x16(self, a: u16x16<Self>, dest: &mut [u16; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u16x16(self, a: u8x32<Self>) -> u16x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u16x16(self, a: u16x16<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u16x16<const SHIFT: usize>(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u16x16<const SHIFT: usize>(
        self,
        a: u16x16<Self>,
        b: u16x16<Self>,
    ) -> u16x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u16x16(self, a: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u16x16(self, a: u16x16<Self>, shift: u32) -> u16x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u16x16(self, a: u16x16<Self>, shift: u32) -> u16x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> mask16x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u16x16(self, a: mask16x16<Self>, b: u16x16<Self>, c: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x16<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u16x16(self, a: u16x16<Self>, b: u16x16<Self>) -> u16x32<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u16x16(self, a: u16x16<Self>) -> (u16x8<Self>, u16x8<Self>);
    #[doc = "Truncate each element to a narrower integer type.\n\nThe number of elements in the result is twice that of the input."]
    fn narrow_u16x16(self, a: u16x16<Self>) -> u8x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u16x16(self, a: u16x16<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u16x16(self, a: u16x16<Self>) -> u32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask16x16(self, val: i16) -> mask16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask16x16(self, val: [i16; 16usize]) -> mask16x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask16x16(self, val: &[i16; 16usize]) -> mask16x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask16x16(self, a: mask16x16<Self>) -> [i16; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask16x16(self, a: &mask16x16<Self>) -> &[i16; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask16x16(self, a: &mut mask16x16<Self>) -> &mut [i16; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask16x16(self, a: mask16x16<Self>, dest: &mut [i16; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask16x16(self, a: u8x32<Self>) -> mask16x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask16x16(self, a: mask16x16<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask16x16<const SHIFT: usize>(
        self,
        a: mask16x16<Self>,
        b: mask16x16<Self>,
    ) -> mask16x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask16x16<const SHIFT: usize>(
        self,
        a: mask16x16<Self>,
        b: mask16x16<Self>,
    ) -> mask16x16<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask16x16(self, a: mask16x16<Self>, b: mask16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask16x16(self, a: mask16x16<Self>, b: mask16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask16x16(self, a: mask16x16<Self>, b: mask16x16<Self>) -> mask16x16<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask16x16(self, a: mask16x16<Self>) -> mask16x16<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask16x16(
        self,
        a: mask16x16<Self>,
        b: mask16x16<Self>,
        c: mask16x16<Self>,
    ) -> mask16x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask16x16(self, a: mask16x16<Self>, b: mask16x16<Self>) -> mask16x16<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask16x16(self, a: mask16x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask16x16(self, a: mask16x16<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask16x16(self, a: mask16x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask16x16(self, a: mask16x16<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask16x16(self, a: mask16x16<Self>, b: mask16x16<Self>) -> mask16x32<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask16x16(self, a: mask16x16<Self>) -> (mask16x8<Self>, mask16x8<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i32x8(self, val: i32) -> i32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i32x8(self, val: [i32; 8usize]) -> i32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i32x8(self, val: &[i32; 8usize]) -> i32x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i32x8(self, a: i32x8<Self>) -> [i32; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i32x8(self, a: &i32x8<Self>) -> &[i32; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i32x8(self, a: &mut i32x8<Self>) -> &mut [i32; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i32x8(self, a: i32x8<Self>, dest: &mut [i32; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i32x8(self, a: u8x32<Self>) -> i32x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i32x8(self, a: i32x8<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i32x8<const SHIFT: usize>(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i32x8<const SHIFT: usize>(
        self,
        a: i32x8<Self>,
        b: i32x8<Self>,
    ) -> i32x8<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i32x8(self, a: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i32x8(self, a: i32x8<Self>, shift: u32) -> i32x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i32x8(self, a: i32x8<Self>, shift: u32) -> i32x8<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> mask32x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i32x8(self, a: mask32x8<Self>, b: i32x8<Self>, c: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_i32x8(self, a: i32x8<Self>, b: i32x8<Self>) -> i32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i32x8(self, a: i32x8<Self>) -> (i32x4<Self>, i32x4<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i32x8(self, a: i32x8<Self>) -> i32x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i32x8(self, a: i32x8<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i32x8(self, a: i32x8<Self>) -> u32x8<Self>;
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_i32x8(self, a: i32x8<Self>) -> f32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u32x8(self, val: u32) -> u32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u32x8(self, val: [u32; 8usize]) -> u32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u32x8(self, val: &[u32; 8usize]) -> u32x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u32x8(self, a: u32x8<Self>) -> [u32; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u32x8(self, a: &u32x8<Self>) -> &[u32; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u32x8(self, a: &mut u32x8<Self>) -> &mut [u32; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u32x8(self, a: u32x8<Self>, dest: &mut [u32; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u32x8(self, a: u8x32<Self>) -> u32x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u32x8(self, a: u32x8<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u32x8<const SHIFT: usize>(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u32x8<const SHIFT: usize>(
        self,
        a: u32x8<Self>,
        b: u32x8<Self>,
    ) -> u32x8<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u32x8(self, a: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u32x8(self, a: u32x8<Self>, shift: u32) -> u32x8<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u32x8(self, a: u32x8<Self>, shift: u32) -> u32x8<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> mask32x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u32x8(self, a: mask32x8<Self>, b: u32x8<Self>, c: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x8<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_u32x8(self, a: u32x8<Self>, b: u32x8<Self>) -> u32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u32x8(self, a: u32x8<Self>) -> (u32x4<Self>, u32x4<Self>);
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u32x8(self, a: u32x8<Self>) -> u8x32<Self>;
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_u32x8(self, a: u32x8<Self>) -> f32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask32x8(self, val: i32) -> mask32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask32x8(self, val: [i32; 8usize]) -> mask32x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask32x8(self, val: &[i32; 8usize]) -> mask32x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask32x8(self, a: mask32x8<Self>) -> [i32; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask32x8(self, a: &mask32x8<Self>) -> &[i32; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask32x8(self, a: &mut mask32x8<Self>) -> &mut [i32; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask32x8(self, a: mask32x8<Self>, dest: &mut [i32; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask32x8(self, a: u8x32<Self>) -> mask32x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask32x8(self, a: mask32x8<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask32x8<const SHIFT: usize>(
        self,
        a: mask32x8<Self>,
        b: mask32x8<Self>,
    ) -> mask32x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask32x8<const SHIFT: usize>(
        self,
        a: mask32x8<Self>,
        b: mask32x8<Self>,
    ) -> mask32x8<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask32x8(self, a: mask32x8<Self>, b: mask32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask32x8(self, a: mask32x8<Self>, b: mask32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask32x8(self, a: mask32x8<Self>, b: mask32x8<Self>) -> mask32x8<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask32x8(self, a: mask32x8<Self>) -> mask32x8<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask32x8(
        self,
        a: mask32x8<Self>,
        b: mask32x8<Self>,
        c: mask32x8<Self>,
    ) -> mask32x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask32x8(self, a: mask32x8<Self>, b: mask32x8<Self>) -> mask32x8<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask32x8(self, a: mask32x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask32x8(self, a: mask32x8<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask32x8(self, a: mask32x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask32x8(self, a: mask32x8<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask32x8(self, a: mask32x8<Self>, b: mask32x8<Self>) -> mask32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask32x8(self, a: mask32x8<Self>) -> (mask32x4<Self>, mask32x4<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f64x4(self, val: f64) -> f64x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f64x4(self, val: [f64; 4usize]) -> f64x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f64x4(self, val: &[f64; 4usize]) -> f64x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f64x4(self, a: f64x4<Self>) -> [f64; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f64x4(self, a: &f64x4<Self>) -> &[f64; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f64x4(self, a: &mut f64x4<Self>) -> &mut [f64; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f64x4(self, a: f64x4<Self>, dest: &mut [f64; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f64x4(self, a: u8x32<Self>) -> f64x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f64x4(self, a: f64x4<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f64x4<const SHIFT: usize>(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f64x4<const SHIFT: usize>(
        self,
        a: f64x4<Self>,
        b: f64x4<Self>,
    ) -> f64x4<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> mask64x4<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f64x4(self, a: f64x4<Self>, b: f64x4<Self>, c: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f64x4(self, a: f64x4<Self>, b: f64x4<Self>, c: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f64x4(self, a: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f64x4(self, a: mask64x4<Self>, b: f64x4<Self>, c: f64x4<Self>) -> f64x4<Self>;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_f64x4(self, a: f64x4<Self>, b: f64x4<Self>) -> f64x8<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_f64x4(self, a: f64x4<Self>) -> (f64x2<Self>, f64x2<Self>);
    #[doc = "Reinterpret the bits of this vector as a vector of `f32` elements.\n\nThe number of elements in the result is twice that of the input."]
    fn reinterpret_f32_f64x4(self, a: f64x4<Self>) -> f32x8<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask64x4(self, val: i64) -> mask64x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask64x4(self, val: [i64; 4usize]) -> mask64x4<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask64x4(self, val: &[i64; 4usize]) -> mask64x4<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask64x4(self, a: mask64x4<Self>) -> [i64; 4usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask64x4(self, a: &mask64x4<Self>) -> &[i64; 4usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask64x4(self, a: &mut mask64x4<Self>) -> &mut [i64; 4usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask64x4(self, a: mask64x4<Self>, dest: &mut [i64; 4usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask64x4(self, a: u8x32<Self>) -> mask64x4<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask64x4(self, a: mask64x4<Self>) -> u8x32<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask64x4<const SHIFT: usize>(
        self,
        a: mask64x4<Self>,
        b: mask64x4<Self>,
    ) -> mask64x4<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask64x4<const SHIFT: usize>(
        self,
        a: mask64x4<Self>,
        b: mask64x4<Self>,
    ) -> mask64x4<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask64x4(self, a: mask64x4<Self>, b: mask64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask64x4(self, a: mask64x4<Self>, b: mask64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask64x4(self, a: mask64x4<Self>, b: mask64x4<Self>) -> mask64x4<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask64x4(self, a: mask64x4<Self>) -> mask64x4<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask64x4(
        self,
        a: mask64x4<Self>,
        b: mask64x4<Self>,
        c: mask64x4<Self>,
    ) -> mask64x4<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask64x4(self, a: mask64x4<Self>, b: mask64x4<Self>) -> mask64x4<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask64x4(self, a: mask64x4<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask64x4(self, a: mask64x4<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask64x4(self, a: mask64x4<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask64x4(self, a: mask64x4<Self>) -> bool;
    #[doc = "Combine two vectors into a single vector with twice the width.\n\n`a` provides the lower elements and `b` provides the upper elements."]
    fn combine_mask64x4(self, a: mask64x4<Self>, b: mask64x4<Self>) -> mask64x8<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask64x4(self, a: mask64x4<Self>) -> (mask64x2<Self>, mask64x2<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f32x16(self, val: f32) -> f32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f32x16(self, val: [f32; 16usize]) -> f32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f32x16(self, val: &[f32; 16usize]) -> f32x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f32x16(self, a: f32x16<Self>) -> [f32; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f32x16(self, a: &f32x16<Self>) -> &[f32; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f32x16(self, a: &mut f32x16<Self>) -> &mut [f32; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f32x16(self, a: f32x16<Self>, dest: &mut [f32; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f32x16(self, a: u8x64<Self>) -> f32x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f32x16(self, a: f32x16<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f32x16<const SHIFT: usize>(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f32x16<const SHIFT: usize>(
        self,
        a: f32x16<Self>,
        b: f32x16<Self>,
    ) -> f32x16<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> mask32x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f32x16(self, a: f32x16<Self>, b: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f32x16(self, a: f32x16<Self>, b: f32x16<Self>, c: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f32x16(self, a: f32x16<Self>, b: f32x16<Self>, c: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f32x16(self, a: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f32x16(self, a: mask32x16<Self>, b: f32x16<Self>, c: f32x16<Self>) -> f32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_f32x16(self, a: f32x16<Self>) -> (f32x8<Self>, f32x8<Self>);
    #[doc = "Reinterpret the bits of this vector as a vector of `f64` elements.\n\nThe number of elements in the result is half that of the input."]
    fn reinterpret_f64_f32x16(self, a: f32x16<Self>) -> f64x8<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `i32` elements.\n\nThis is a bitwise reinterpretation only, and does not perform any conversions."]
    fn reinterpret_i32_f32x16(self, a: f32x16<Self>) -> i32x16<Self>;
    #[doc = "Load elements from an array with 4-way interleaving.\n\nReads consecutive elements and deinterleaves them into a single vector."]
    fn load_interleaved_128_f32x16(self, src: &[f32; 16usize]) -> f32x16<Self>;
    #[doc = "Store elements to an array with 4-way interleaving.\n\nInterleaves the vector elements and writes them consecutively to memory."]
    fn store_interleaved_128_f32x16(self, a: f32x16<Self>, dest: &mut [f32; 16usize]) -> ();
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_f32x16(self, a: f32x16<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_f32x16(self, a: f32x16<Self>) -> u32x16<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results.\n\nOn x86 platforms, this operation will still be slower than converting to `i32`, because there is no native instruction for converting to `u32` (at least until AVX-512, which is currently not supported).\nIf you know your values fit within range of an `i32`, you should convert to an `i32` and cast to your desired datatype afterwards."]
    fn cvt_u32_f32x16(self, a: f32x16<Self>) -> u32x16<Self>;
    #[doc = "Convert each floating-point element to an unsigned 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_u32_precise_f32x16(self, a: f32x16<Self>) -> u32x16<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values or NaN will produce implementation-defined results."]
    fn cvt_i32_f32x16(self, a: f32x16<Self>) -> i32x16<Self>;
    #[doc = "Convert each floating-point element to a signed 32-bit integer, truncating towards zero.\n\nOut-of-range values are saturated to the closest in-range value. NaN becomes 0."]
    fn cvt_i32_precise_f32x16(self, a: f32x16<Self>) -> i32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i8x64(self, val: i8) -> i8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i8x64(self, val: [i8; 64usize]) -> i8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i8x64(self, val: &[i8; 64usize]) -> i8x64<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i8x64(self, a: i8x64<Self>) -> [i8; 64usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i8x64(self, a: &i8x64<Self>) -> &[i8; 64usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i8x64(self, a: &mut i8x64<Self>) -> &mut [i8; 64usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i8x64(self, a: i8x64<Self>, dest: &mut [i8; 64usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i8x64(self, a: u8x64<Self>) -> i8x64<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i8x64(self, a: i8x64<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i8x64<const SHIFT: usize>(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i8x64<const SHIFT: usize>(
        self,
        a: i8x64<Self>,
        b: i8x64<Self>,
    ) -> i8x64<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i8x64(self, a: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i8x64(self, a: i8x64<Self>, shift: u32) -> i8x64<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i8x64(self, a: i8x64<Self>, shift: u32) -> i8x64<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> mask8x64<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i8x64(self, a: mask8x64<Self>, b: i8x64<Self>, c: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i8x64(self, a: i8x64<Self>, b: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i8x64(self, a: i8x64<Self>) -> (i8x32<Self>, i8x32<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i8x64(self, a: i8x64<Self>) -> i8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i8x64(self, a: i8x64<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i8x64(self, a: i8x64<Self>) -> u32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u8x64(self, val: u8) -> u8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u8x64(self, val: [u8; 64usize]) -> u8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u8x64(self, val: &[u8; 64usize]) -> u8x64<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u8x64(self, a: u8x64<Self>) -> [u8; 64usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u8x64(self, a: &u8x64<Self>) -> &[u8; 64usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u8x64(self, a: &mut u8x64<Self>) -> &mut [u8; 64usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u8x64(self, a: u8x64<Self>, dest: &mut [u8; 64usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u8x64(self, a: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u8x64(self, a: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u8x64<const SHIFT: usize>(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u8x64<const SHIFT: usize>(
        self,
        a: u8x64<Self>,
        b: u8x64<Self>,
    ) -> u8x64<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u8x64(self, a: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u8x64(self, a: u8x64<Self>, shift: u32) -> u8x64<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u8x64(self, a: u8x64<Self>, shift: u32) -> u8x64<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u8x64(self, a: mask8x64<Self>, b: u8x64<Self>, c: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u8x64(self, a: u8x64<Self>, b: u8x64<Self>) -> u8x64<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u8x64(self, a: u8x64<Self>) -> (u8x32<Self>, u8x32<Self>);
    #[doc = "Load elements from an array with 4-way interleaving.\n\nReads consecutive elements and deinterleaves them into a single vector."]
    fn load_interleaved_128_u8x64(self, src: &[u8; 64usize]) -> u8x64<Self>;
    #[doc = "Store elements to an array with 4-way interleaving.\n\nInterleaves the vector elements and writes them consecutively to memory."]
    fn store_interleaved_128_u8x64(self, a: u8x64<Self>, dest: &mut [u8; 64usize]) -> ();
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u8x64(self, a: u8x64<Self>) -> u32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask8x64(self, val: i8) -> mask8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask8x64(self, val: [i8; 64usize]) -> mask8x64<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask8x64(self, val: &[i8; 64usize]) -> mask8x64<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask8x64(self, a: mask8x64<Self>) -> [i8; 64usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask8x64(self, a: &mask8x64<Self>) -> &[i8; 64usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask8x64(self, a: &mut mask8x64<Self>) -> &mut [i8; 64usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask8x64(self, a: mask8x64<Self>, dest: &mut [i8; 64usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask8x64(self, a: u8x64<Self>) -> mask8x64<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask8x64(self, a: mask8x64<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask8x64<const SHIFT: usize>(
        self,
        a: mask8x64<Self>,
        b: mask8x64<Self>,
    ) -> mask8x64<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask8x64<const SHIFT: usize>(
        self,
        a: mask8x64<Self>,
        b: mask8x64<Self>,
    ) -> mask8x64<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask8x64(self, a: mask8x64<Self>, b: mask8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask8x64(self, a: mask8x64<Self>, b: mask8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask8x64(self, a: mask8x64<Self>, b: mask8x64<Self>) -> mask8x64<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask8x64(self, a: mask8x64<Self>) -> mask8x64<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask8x64(
        self,
        a: mask8x64<Self>,
        b: mask8x64<Self>,
        c: mask8x64<Self>,
    ) -> mask8x64<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask8x64(self, a: mask8x64<Self>, b: mask8x64<Self>) -> mask8x64<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask8x64(self, a: mask8x64<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask8x64(self, a: mask8x64<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask8x64(self, a: mask8x64<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask8x64(self, a: mask8x64<Self>) -> bool;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask8x64(self, a: mask8x64<Self>) -> (mask8x32<Self>, mask8x32<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i16x32(self, val: i16) -> i16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i16x32(self, val: [i16; 32usize]) -> i16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i16x32(self, val: &[i16; 32usize]) -> i16x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i16x32(self, a: i16x32<Self>) -> [i16; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i16x32(self, a: &i16x32<Self>) -> &[i16; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i16x32(self, a: &mut i16x32<Self>) -> &mut [i16; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i16x32(self, a: i16x32<Self>, dest: &mut [i16; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i16x32(self, a: u8x64<Self>) -> i16x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i16x32(self, a: i16x32<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i16x32<const SHIFT: usize>(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i16x32<const SHIFT: usize>(
        self,
        a: i16x32<Self>,
        b: i16x32<Self>,
    ) -> i16x32<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i16x32(self, a: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i16x32(self, a: i16x32<Self>, shift: u32) -> i16x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i16x32(self, a: i16x32<Self>, shift: u32) -> i16x32<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> mask16x32<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i16x32(self, a: mask16x32<Self>, b: i16x32<Self>, c: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i16x32(self, a: i16x32<Self>, b: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i16x32(self, a: i16x32<Self>) -> (i16x16<Self>, i16x16<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i16x32(self, a: i16x32<Self>) -> i16x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i16x32(self, a: i16x32<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i16x32(self, a: i16x32<Self>) -> u32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u16x32(self, val: u16) -> u16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u16x32(self, val: [u16; 32usize]) -> u16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u16x32(self, val: &[u16; 32usize]) -> u16x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u16x32(self, a: u16x32<Self>) -> [u16; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u16x32(self, a: &u16x32<Self>) -> &[u16; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u16x32(self, a: &mut u16x32<Self>) -> &mut [u16; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u16x32(self, a: u16x32<Self>, dest: &mut [u16; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u16x32(self, a: u8x64<Self>) -> u16x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u16x32(self, a: u16x32<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u16x32<const SHIFT: usize>(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u16x32<const SHIFT: usize>(
        self,
        a: u16x32<Self>,
        b: u16x32<Self>,
    ) -> u16x32<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u16x32(self, a: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u16x32(self, a: u16x32<Self>, shift: u32) -> u16x32<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u16x32(self, a: u16x32<Self>, shift: u32) -> u16x32<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> mask16x32<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u16x32(self, a: mask16x32<Self>, b: u16x32<Self>, c: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u16x32(self, a: u16x32<Self>, b: u16x32<Self>) -> u16x32<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u16x32(self, a: u16x32<Self>) -> (u16x16<Self>, u16x16<Self>);
    #[doc = "Load elements from an array with 4-way interleaving.\n\nReads consecutive elements and deinterleaves them into a single vector."]
    fn load_interleaved_128_u16x32(self, src: &[u16; 32usize]) -> u16x32<Self>;
    #[doc = "Store elements to an array with 4-way interleaving.\n\nInterleaves the vector elements and writes them consecutively to memory."]
    fn store_interleaved_128_u16x32(self, a: u16x32<Self>, dest: &mut [u16; 32usize]) -> ();
    #[doc = "Truncate each element to a narrower integer type.\n\nThe number of elements in the result is twice that of the input."]
    fn narrow_u16x32(self, a: u16x32<Self>) -> u8x32<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u16x32(self, a: u16x32<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_u16x32(self, a: u16x32<Self>) -> u32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask16x32(self, val: i16) -> mask16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask16x32(self, val: [i16; 32usize]) -> mask16x32<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask16x32(self, val: &[i16; 32usize]) -> mask16x32<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask16x32(self, a: mask16x32<Self>) -> [i16; 32usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask16x32(self, a: &mask16x32<Self>) -> &[i16; 32usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask16x32(self, a: &mut mask16x32<Self>) -> &mut [i16; 32usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask16x32(self, a: mask16x32<Self>, dest: &mut [i16; 32usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask16x32(self, a: u8x64<Self>) -> mask16x32<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask16x32(self, a: mask16x32<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask16x32<const SHIFT: usize>(
        self,
        a: mask16x32<Self>,
        b: mask16x32<Self>,
    ) -> mask16x32<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask16x32<const SHIFT: usize>(
        self,
        a: mask16x32<Self>,
        b: mask16x32<Self>,
    ) -> mask16x32<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask16x32(self, a: mask16x32<Self>, b: mask16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask16x32(self, a: mask16x32<Self>, b: mask16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask16x32(self, a: mask16x32<Self>, b: mask16x32<Self>) -> mask16x32<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask16x32(self, a: mask16x32<Self>) -> mask16x32<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask16x32(
        self,
        a: mask16x32<Self>,
        b: mask16x32<Self>,
        c: mask16x32<Self>,
    ) -> mask16x32<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask16x32(self, a: mask16x32<Self>, b: mask16x32<Self>) -> mask16x32<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask16x32(self, a: mask16x32<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask16x32(self, a: mask16x32<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask16x32(self, a: mask16x32<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask16x32(self, a: mask16x32<Self>) -> bool;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask16x32(self, a: mask16x32<Self>) -> (mask16x16<Self>, mask16x16<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_i32x16(self, val: i32) -> i32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_i32x16(self, val: [i32; 16usize]) -> i32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_i32x16(self, val: &[i32; 16usize]) -> i32x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_i32x16(self, a: i32x16<Self>) -> [i32; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_i32x16(self, a: &i32x16<Self>) -> &[i32; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_i32x16(self, a: &mut i32x16<Self>) -> &mut [i32; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_i32x16(self, a: i32x16<Self>, dest: &mut [i32; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_i32x16(self, a: u8x64<Self>) -> i32x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_i32x16(self, a: i32x16<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_i32x16<const SHIFT: usize>(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_i32x16<const SHIFT: usize>(
        self,
        a: i32x16<Self>,
        b: i32x16<Self>,
    ) -> i32x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_i32x16(self, a: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_i32x16(self, a: i32x16<Self>, shift: u32) -> i32x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_i32x16(self, a: i32x16<Self>, shift: u32) -> i32x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> mask32x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_i32x16(self, a: mask32x16<Self>, b: i32x16<Self>, c: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_i32x16(self, a: i32x16<Self>, b: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_i32x16(self, a: i32x16<Self>) -> (i32x8<Self>, i32x8<Self>);
    #[doc = "Negate each element of the vector, wrapping on overflow."]
    fn neg_i32x16(self, a: i32x16<Self>) -> i32x16<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_i32x16(self, a: i32x16<Self>) -> u8x64<Self>;
    #[doc = "Reinterpret the bits of this vector as a vector of `u32` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u32_i32x16(self, a: i32x16<Self>) -> u32x16<Self>;
    #[doc = "Convert each signed 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_i32x16(self, a: i32x16<Self>) -> f32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_u32x16(self, val: u32) -> u32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_u32x16(self, val: [u32; 16usize]) -> u32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_u32x16(self, val: &[u32; 16usize]) -> u32x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_u32x16(self, a: u32x16<Self>) -> [u32; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_u32x16(self, a: &u32x16<Self>) -> &[u32; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_u32x16(self, a: &mut u32x16<Self>) -> &mut [u32; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_u32x16(self, a: u32x16<Self>, dest: &mut [u32; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_u32x16(self, a: u8x64<Self>) -> u32x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_u32x16(self, a: u32x16<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_u32x16<const SHIFT: usize>(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_u32x16<const SHIFT: usize>(
        self,
        a: u32x16<Self>,
        b: u32x16<Self>,
    ) -> u32x16<Self>;
    #[doc = "Add two vectors element-wise, wrapping on overflow."]
    fn add_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Subtract two vectors element-wise, wrapping on overflow."]
    fn sub_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Multiply two vectors element-wise, wrapping on overflow."]
    fn mul_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Compute the bitwise AND of two vectors."]
    fn and_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Compute the bitwise OR of two vectors."]
    fn or_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Compute the bitwise XOR of two vectors."]
    fn xor_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Compute the bitwise NOT of the vector."]
    fn not_u32x16(self, a: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right."]
    fn shl_u32x16(self, a: u32x16<Self>, shift: u32) -> u32x16<Self>;
    #[doc = "Shift each element left by the given number of bits.\n\nBits shifted out of the left side are discarded, and zeros are shifted in on the right.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shlv_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Shift each element right by the given number of bits.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated."]
    fn shr_u32x16(self, a: u32x16<Self>, shift: u32) -> u32x16<Self>;
    #[doc = "Shift each element right by the corresponding element in another vector.\n\nFor unsigned integers, zeros are shifted in on the left. For signed integers, the sign bit is replicated.\n\nThis operation is not implemented in hardware on all platforms. On WebAssembly, and on x86 platforms without AVX2, this will use a fallback scalar implementation."]
    fn shrv_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> mask32x16<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_u32x16(self, a: mask32x16<Self>, b: u32x16<Self>, c: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max_u32x16(self, a: u32x16<Self>, b: u32x16<Self>) -> u32x16<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_u32x16(self, a: u32x16<Self>) -> (u32x8<Self>, u32x8<Self>);
    #[doc = "Load elements from an array with 4-way interleaving.\n\nReads consecutive elements and deinterleaves them into a single vector."]
    fn load_interleaved_128_u32x16(self, src: &[u32; 16usize]) -> u32x16<Self>;
    #[doc = "Store elements to an array with 4-way interleaving.\n\nInterleaves the vector elements and writes them consecutively to memory."]
    fn store_interleaved_128_u32x16(self, a: u32x16<Self>, dest: &mut [u32; 16usize]) -> ();
    #[doc = "Reinterpret the bits of this vector as a vector of `u8` elements.\n\nThe total bit width is preserved; the number of elements changes accordingly."]
    fn reinterpret_u8_u32x16(self, a: u32x16<Self>) -> u8x64<Self>;
    #[doc = "Convert each unsigned 32-bit integer element to a floating-point value.\n\nValues that cannot be exactly represented are rounded to the nearest representable value."]
    fn cvt_f32_u32x16(self, a: u32x16<Self>) -> f32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask32x16(self, val: i32) -> mask32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask32x16(self, val: [i32; 16usize]) -> mask32x16<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask32x16(self, val: &[i32; 16usize]) -> mask32x16<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask32x16(self, a: mask32x16<Self>) -> [i32; 16usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask32x16(self, a: &mask32x16<Self>) -> &[i32; 16usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask32x16(self, a: &mut mask32x16<Self>) -> &mut [i32; 16usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask32x16(self, a: mask32x16<Self>, dest: &mut [i32; 16usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask32x16(self, a: u8x64<Self>) -> mask32x16<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask32x16(self, a: mask32x16<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask32x16<const SHIFT: usize>(
        self,
        a: mask32x16<Self>,
        b: mask32x16<Self>,
    ) -> mask32x16<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask32x16<const SHIFT: usize>(
        self,
        a: mask32x16<Self>,
        b: mask32x16<Self>,
    ) -> mask32x16<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask32x16(self, a: mask32x16<Self>, b: mask32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask32x16(self, a: mask32x16<Self>, b: mask32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask32x16(self, a: mask32x16<Self>, b: mask32x16<Self>) -> mask32x16<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask32x16(self, a: mask32x16<Self>) -> mask32x16<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask32x16(
        self,
        a: mask32x16<Self>,
        b: mask32x16<Self>,
        c: mask32x16<Self>,
    ) -> mask32x16<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask32x16(self, a: mask32x16<Self>, b: mask32x16<Self>) -> mask32x16<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask32x16(self, a: mask32x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask32x16(self, a: mask32x16<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask32x16(self, a: mask32x16<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask32x16(self, a: mask32x16<Self>) -> bool;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask32x16(self, a: mask32x16<Self>) -> (mask32x8<Self>, mask32x8<Self>);
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_f64x8(self, val: f64) -> f64x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_f64x8(self, val: [f64; 8usize]) -> f64x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_f64x8(self, val: &[f64; 8usize]) -> f64x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_f64x8(self, a: f64x8<Self>) -> [f64; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_f64x8(self, a: &f64x8<Self>) -> &[f64; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_f64x8(self, a: &mut f64x8<Self>) -> &mut [f64; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_f64x8(self, a: f64x8<Self>, dest: &mut [f64; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_f64x8(self, a: u8x64<Self>) -> f64x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_f64x8(self, a: f64x8<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_f64x8<const SHIFT: usize>(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_f64x8<const SHIFT: usize>(
        self,
        a: f64x8<Self>,
        b: f64x8<Self>,
    ) -> f64x8<Self>;
    #[doc = "Compute the absolute value of each element."]
    fn abs_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Negate each element of the vector."]
    fn neg_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Add two vectors element-wise."]
    fn add_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Subtract two vectors element-wise."]
    fn sub_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Multiply two vectors element-wise."]
    fn mul_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Divide two vectors element-wise."]
    fn div_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return a vector with the magnitude of `a` and the sign of `b` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `a` is less than `b`, and all zeroes if not."]
    fn simd_lt_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `a` is less than or equal to `b`, and all zeroes if not."]
    fn simd_le_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `a` is greater than or equal to `b`, and all zeroes if not."]
    fn simd_ge_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `a` is greater than `b`, and all zeroes if not."]
    fn simd_gt_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> mask64x8<Self>;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise_f64x8(self, a: f64x8<Self>, b: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Compute `(a * b) + c` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add_f64x8(self, a: f64x8<Self>, b: f64x8<Self>, c: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Compute `(a * b) - c` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub_f64x8(self, a: f64x8<Self>, b: f64x8<Self>, c: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `a - a.trunc()`."]
    fn fract_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc_f64x8(self, a: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Select elements from b and c based on the mask operand a.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_f64x8(self, a: mask64x8<Self>, b: f64x8<Self>, c: f64x8<Self>) -> f64x8<Self>;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_f64x8(self, a: f64x8<Self>) -> (f64x4<Self>, f64x4<Self>);
    #[doc = "Reinterpret the bits of this vector as a vector of `f32` elements.\n\nThe number of elements in the result is twice that of the input."]
    fn reinterpret_f32_f64x8(self, a: f64x8<Self>) -> f32x16<Self>;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat_mask64x8(self, val: i64) -> mask64x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_mask64x8(self, val: [i64; 8usize]) -> mask64x8<Self>;
    #[doc = "Create a SIMD vector from an array of the same length."]
    fn load_array_ref_mask64x8(self, val: &[i64; 8usize]) -> mask64x8<Self>;
    #[doc = "Convert a SIMD vector to an array."]
    fn as_array_mask64x8(self, a: mask64x8<Self>) -> [i64; 8usize];
    #[doc = "Project a reference to a SIMD vector to a reference to the equivalent array."]
    fn as_array_ref_mask64x8(self, a: &mask64x8<Self>) -> &[i64; 8usize];
    #[doc = "Project a mutable reference to a SIMD vector to a mutable reference to the equivalent array."]
    fn as_array_mut_mask64x8(self, a: &mut mask64x8<Self>) -> &mut [i64; 8usize];
    #[doc = "Store a SIMD vector into an array of the same length."]
    fn store_array_mask64x8(self, a: mask64x8<Self>, dest: &mut [i64; 8usize]) -> ();
    #[doc = "Reinterpret a vector of bytes as a SIMD vector of a given type, with the equivalent byte length."]
    fn cvt_from_bytes_mask64x8(self, a: u8x64<Self>) -> mask64x8<Self>;
    #[doc = "Reinterpret a SIMD vector as a vector of bytes, with the equivalent byte length."]
    fn cvt_to_bytes_mask64x8(self, a: mask64x8<Self>) -> u8x64<Self>;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide_mask64x8<const SHIFT: usize>(
        self,
        a: mask64x8<Self>,
        b: mask64x8<Self>,
    ) -> mask64x8<Self>;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks_mask64x8<const SHIFT: usize>(
        self,
        a: mask64x8<Self>,
        b: mask64x8<Self>,
    ) -> mask64x8<Self>;
    #[doc = "Compute the logical AND of two masks."]
    fn and_mask64x8(self, a: mask64x8<Self>, b: mask64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compute the logical OR of two masks."]
    fn or_mask64x8(self, a: mask64x8<Self>, b: mask64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compute the logical XOR of two masks."]
    fn xor_mask64x8(self, a: mask64x8<Self>, b: mask64x8<Self>) -> mask64x8<Self>;
    #[doc = "Compute the logical NOT of the mask."]
    fn not_mask64x8(self, a: mask64x8<Self>) -> mask64x8<Self>;
    #[doc = "Select elements from `b` and `c` based on the mask operand `a`.\n\nThis operation's behavior is unspecified if each lane of a is not the all-zeroes or all-ones bit pattern. See the [`Select`] trait's documentation for more information."]
    fn select_mask64x8(
        self,
        a: mask64x8<Self>,
        b: mask64x8<Self>,
        c: mask64x8<Self>,
    ) -> mask64x8<Self>;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq_mask64x8(self, a: mask64x8<Self>, b: mask64x8<Self>) -> mask64x8<Self>;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true_mask64x8(self, a: mask64x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true_mask64x8(self, a: mask64x8<Self>) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false_mask64x8(self, a: mask64x8<Self>) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false_mask64x8(self, a: mask64x8<Self>) -> bool;
    #[doc = "Split a vector into two vectors of half the width.\n\nReturns a tuple of (lower half, upper half)."]
    fn split_mask64x8(self, a: mask64x8<Self>) -> (mask64x4<Self>, mask64x4<Self>);
}
pub(crate) mod arch_types {
    #[expect(
        unnameable_types,
        reason = "The native vector types that back a `Simd` implementation are an internal implementation detail, and intentionally kept private"
    )]
    pub trait ArchTypes {
        type f32x4: Copy + Send + Sync;
        type i8x16: Copy + Send + Sync;
        type u8x16: Copy + Send + Sync;
        type mask8x16: Copy + Send + Sync;
        type i16x8: Copy + Send + Sync;
        type u16x8: Copy + Send + Sync;
        type mask16x8: Copy + Send + Sync;
        type i32x4: Copy + Send + Sync;
        type u32x4: Copy + Send + Sync;
        type mask32x4: Copy + Send + Sync;
        type f64x2: Copy + Send + Sync;
        type mask64x2: Copy + Send + Sync;
        type f32x8: Copy + Send + Sync;
        type i8x32: Copy + Send + Sync;
        type u8x32: Copy + Send + Sync;
        type mask8x32: Copy + Send + Sync;
        type i16x16: Copy + Send + Sync;
        type u16x16: Copy + Send + Sync;
        type mask16x16: Copy + Send + Sync;
        type i32x8: Copy + Send + Sync;
        type u32x8: Copy + Send + Sync;
        type mask32x8: Copy + Send + Sync;
        type f64x4: Copy + Send + Sync;
        type mask64x4: Copy + Send + Sync;
        type f32x16: Copy + Send + Sync;
        type i8x64: Copy + Send + Sync;
        type u8x64: Copy + Send + Sync;
        type mask8x64: Copy + Send + Sync;
        type i16x32: Copy + Send + Sync;
        type u16x32: Copy + Send + Sync;
        type mask16x32: Copy + Send + Sync;
        type i32x16: Copy + Send + Sync;
        type u32x16: Copy + Send + Sync;
        type mask32x16: Copy + Send + Sync;
        type f64x8: Copy + Send + Sync;
        type mask64x8: Copy + Send + Sync;
    }
}
#[doc = r" Base functionality implemented by all SIMD vectors."]
pub trait SimdBase<S: Simd>:
    Copy
    + Sync
    + Send
    + 'static
    + crate::Bytes
    + SimdFrom<Self::Element, S>
    + core::ops::Index<usize, Output = Self::Element>
    + core::ops::IndexMut<usize, Output = Self::Element>
    + core::ops::Deref<Target = Self::Array>
    + core::ops::DerefMut<Target = Self::Array>
{
    #[doc = r" The type of this vector's elements."]
    type Element: SimdElement;
    #[doc = r" This vector type's lane count. This is useful when you're"]
    #[doc = r" working with a native-width vector (e.g. [`Simd::f32s`]) and"]
    #[doc = r" want to process data in native-width chunks."]
    const N: usize;
    #[doc = r" A SIMD vector mask with the same number of elements."]
    #[doc = r""]
    #[doc = r" The mask element is represented as an integer which is"]
    #[doc = r" all-0 for `false` and all-1 for `true`. When we get deep"]
    #[doc = r" into AVX-512, we need to think about predication masks."]
    #[doc = r""]
    #[doc = r" One possibility to consider is that the SIMD trait grows"]
    #[doc = r" `maskAxB` associated types."]
    type Mask: SimdMask<S, Element = <Self::Element as SimdElement>::Mask>;
    #[doc = r" A 128-bit SIMD vector of the same scalar type."]
    type Block: SimdBase<S, Element = Self::Element>;
    #[doc = r" The array type that this vector type corresponds to, which will"]
    #[doc = r" always be `[Self::Element; Self::N]`. It has the same layout as"]
    #[doc = r" this vector type, but likely has a lower alignment."]
    type Array;
    #[doc = r" Get the [`Simd`] implementation associated with this type."]
    fn witness(&self) -> S;
    fn as_slice(&self) -> &[Self::Element];
    fn as_mut_slice(&mut self) -> &mut [Self::Element];
    #[doc = r" Create a SIMD vector from a slice."]
    #[doc = r""]
    #[doc = r" The slice must be the proper width."]
    fn from_slice(simd: S, slice: &[Self::Element]) -> Self;
    #[doc = r" Store a SIMD vector into a slice."]
    #[doc = r""]
    #[doc = r" The slice must be the proper width."]
    fn store_slice(&self, slice: &mut [Self::Element]);
    #[doc = r" Create a SIMD vector from a 128-bit vector of the same scalar"]
    #[doc = r" type, repeated."]
    fn block_splat(block: Self::Block) -> Self;
    #[doc = r" Create a SIMD vector where each element is produced by"]
    #[doc = r" calling `f` with that element's lane index (from 0 to"]
    #[doc = r" [`SimdBase::N`] - 1)."]
    fn from_fn(simd: S, f: impl FnMut(usize) -> Self::Element) -> Self;
    #[doc = "Create a SIMD vector with all elements set to the given value."]
    fn splat(simd: S, val: Self::Element) -> Self;
    #[doc = "Concatenate `[self, rhs]` and extract `Self::N` elements starting at index `SHIFT`.\n\n`SHIFT` must be within [0, `Self::N`].\n\nThis can be used to implement a \"shift items\" operation by providing all zeroes as one operand. For a left shift, the right-hand side should be all zeroes. For a right shift by `M` items, the left-hand side should be all zeroes, and the shift amount will be `Self::N - M`.\n\nThis can also be used to rotate items within a vector by providing the same vector as both operands.\n\n```text\n\nslide::<1>([a b c d], [e f g h]) == [b c d e]\n\n```"]
    fn slide<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Like `slide`, but operates independently on each 128-bit block."]
    fn slide_within_blocks<const SHIFT: usize>(self, rhs: impl SimdInto<Self, S>) -> Self;
}
#[doc = r" Functionality implemented by floating-point SIMD vectors."]
pub trait SimdFloat<S: Simd>:
    SimdBase<S>
    + core::ops::Neg<Output = Self>
    + core::ops::Add<Output = Self>
    + core::ops::AddAssign
    + core::ops::Add<Self::Element, Output = Self>
    + core::ops::AddAssign<Self::Element>
    + core::ops::Sub<Output = Self>
    + core::ops::SubAssign
    + core::ops::Sub<Self::Element, Output = Self>
    + core::ops::SubAssign<Self::Element>
    + core::ops::Mul<Output = Self>
    + core::ops::MulAssign
    + core::ops::Mul<Self::Element, Output = Self>
    + core::ops::MulAssign<Self::Element>
    + core::ops::Div<Output = Self>
    + core::ops::DivAssign
    + core::ops::Div<Self::Element, Output = Self>
    + core::ops::DivAssign<Self::Element>
{
    #[doc = r" Convert this floating-point type to an integer. This is a convenience method that"]
    #[doc = r" delegates to [`SimdCvtTruncate::truncate_from`], and can only be called if there"]
    #[doc = r" actually exists a target type of the same bit width (currently, only `u32` and"]
    #[doc = r" `i32`)."]
    #[doc = r""]
    #[doc = r" For more information about the semantics of this specific conversion, see the"]
    #[doc = r" concrete `SimdCvtTruncate` implementations for integer types."]
    #[inline(always)]
    fn to_int<T: SimdCvtTruncate<Self>>(self) -> T {
        T::truncate_from(self)
    }
    #[doc = r" Convert this floating-point type to an integer, saturating on overflow and returning"]
    #[doc = r" 0 for NaN. This is a convenience method that delegates to"]
    #[doc = r" [`SimdCvtTruncate::truncate_from_precise`], and can only be called if there actually"]
    #[doc = r" exists a target type of the same bit width (currently, only `u32` and `i32`)."]
    #[doc = r""]
    #[doc = r" For more information about the semantics of this specific conversion, see the"]
    #[doc = r" concrete `SimdCvtTruncate` implementations for integer types."]
    #[inline(always)]
    fn to_int_precise<T: SimdCvtTruncate<Self>>(self) -> T {
        T::truncate_from_precise(self)
    }
    #[doc = "Compute the absolute value of each element."]
    fn abs(self) -> Self;
    #[doc = "Compute the square root of each element.\n\nNegative elements other than `-0.0` will become NaN."]
    fn sqrt(self) -> Self;
    #[doc = "Return a vector with the magnitude of `self` and the sign of `rhs` for each element.\n\nThis operation copies the sign bit, so if an input element is NaN, the output element will be a NaN with the same payload and a copied sign bit."]
    fn copysign(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `self` is less than `rhs`, and all zeroes if not."]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `self` is less than or equal to `rhs`, and all zeroes if not."]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `self` is greater than or equal to `rhs`, and all zeroes if not."]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `self` is greater than `rhs`, and all zeroes if not."]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `max_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf either operand is NaN, the result for that lane is implementation-defined-- it could be either the first or second operand. See `min_precise` for a version that returns the non-NaN operand if only one is NaN.\n\nIf one operand is positive zero and the other is negative zero, the result is also implementation-defined, and it could be either one."]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise maximum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn max_precise(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise minimum of two vectors.\n\nIf one operand is a quiet NaN and the other is not, this operation will choose the non-NaN operand.\n\nIf one operand is positive zero and the other is negative zero, the result is implementation-defined, and it could be either one.\n\nIf an operand is a *signaling* NaN, the result is not just implementation-defined, but fully non-deterministic: it may be either NaN or the non-NaN operand.\nSignaling NaN values are not produced by floating-point math operations, only from manual initialization with specific bit patterns. You probably don't need to worry about them."]
    fn min_precise(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Compute `(self * op1) + op2` (fused multiply-add) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by an add, which will result in two rounding errors."]
    fn mul_add(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self;
    #[doc = "Compute `(self * op1) - op2` (fused multiply-subtract) for each element.\n\nDepending on hardware support, the result may be computed with only one rounding error, or may be implemented as a regular multiply followed by a subtract, which will result in two rounding errors."]
    fn mul_sub(self, op1: impl SimdInto<Self, S>, op2: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the largest integer less than or equal to each element, that is, round towards negative infinity."]
    fn floor(self) -> Self;
    #[doc = "Return the smallest integer greater than or equal to each element, that is, round towards positive infinity."]
    fn ceil(self) -> Self;
    #[doc = "Round each element to the nearest integer, with ties rounding to the nearest even integer.\n\nThere is no corresponding `round` operation. Rust's `round` operation rounds ties away from zero, a behavior it inherited from C. That behavior is not implemented across all platforms, whereas round-ties-even is."]
    fn round_ties_even(self) -> Self;
    #[doc = "Return the fractional part of each element.\n\nThis is equivalent to `self - self.trunc()`."]
    fn fract(self) -> Self;
    #[doc = "Return the integer part of each element, rounding towards zero."]
    fn trunc(self) -> Self;
}
#[doc = r" Functionality implemented by (signed and unsigned) integer SIMD vectors."]
pub trait SimdInt<S: Simd>:
    SimdBase<S>
    + core::ops::Add<Output = Self>
    + core::ops::AddAssign
    + core::ops::Add<Self::Element, Output = Self>
    + core::ops::AddAssign<Self::Element>
    + core::ops::Sub<Output = Self>
    + core::ops::SubAssign
    + core::ops::Sub<Self::Element, Output = Self>
    + core::ops::SubAssign<Self::Element>
    + core::ops::Mul<Output = Self>
    + core::ops::MulAssign
    + core::ops::Mul<Self::Element, Output = Self>
    + core::ops::MulAssign<Self::Element>
    + core::ops::BitAnd<Output = Self>
    + core::ops::BitAndAssign
    + core::ops::BitAnd<Self::Element, Output = Self>
    + core::ops::BitAndAssign<Self::Element>
    + core::ops::BitOr<Output = Self>
    + core::ops::BitOrAssign
    + core::ops::BitOr<Self::Element, Output = Self>
    + core::ops::BitOrAssign<Self::Element>
    + core::ops::BitXor<Output = Self>
    + core::ops::BitXorAssign
    + core::ops::BitXor<Self::Element, Output = Self>
    + core::ops::BitXorAssign<Self::Element>
    + core::ops::Not<Output = Self>
    + core::ops::Shl<u32, Output = Self>
    + core::ops::ShlAssign<u32>
    + core::ops::Shl<Output = Self>
    + core::ops::ShlAssign
    + core::ops::Shr<u32, Output = Self>
    + core::ops::ShrAssign<u32>
    + core::ops::Shr<Output = Self>
    + core::ops::ShrAssign
{
    #[doc = r" Convert this integer type to a floating-point type. This is a convenience method"]
    #[doc = r" that delegates to [`SimdCvtFloat::float_from`], and can only be called if there"]
    #[doc = r" actually exists a target type of the same bit width (currently, only `f32`)."]
    #[inline(always)]
    fn to_float<T: SimdCvtFloat<Self>>(self) -> T {
        T::float_from(self)
    }
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for less than.\n\nReturns a mask where each element is all ones if `self` is less than `rhs`, and all zeroes if not."]
    fn simd_lt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for less than or equal.\n\nReturns a mask where each element is all ones if `self` is less than or equal to `rhs`, and all zeroes if not."]
    fn simd_le(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for greater than or equal.\n\nReturns a mask where each element is all ones if `self` is greater than or equal to `rhs`, and all zeroes if not."]
    fn simd_ge(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Compare two vectors element-wise for greater than.\n\nReturns a mask where each element is all ones if `self` is greater than `rhs`, and all zeroes if not."]
    fn simd_gt(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Interleave the lower half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, b0, a1, b1]`."]
    fn zip_low(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Interleave the upper half elements of two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a2, b2, a3, b3]`."]
    fn zip_high(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Extract even-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a0, a2, b0, b2]`."]
    fn unzip_low(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Extract odd-indexed elements from two vectors.\n\nFor vectors `[a0, a1, a2, a3]` and `[b0, b1, b2, b3]`, returns `[a1, a3, b1, b3]`."]
    fn unzip_high(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise minimum of two vectors."]
    fn min(self, rhs: impl SimdInto<Self, S>) -> Self;
    #[doc = "Return the element-wise maximum of two vectors."]
    fn max(self, rhs: impl SimdInto<Self, S>) -> Self;
}
#[doc = r" Functionality implemented by SIMD masks."]
pub trait SimdMask<S: Simd>:
    SimdBase<S>
    + core::ops::BitAnd<Output = Self>
    + core::ops::BitAndAssign
    + core::ops::BitAnd<Self::Element, Output = Self>
    + core::ops::BitAndAssign<Self::Element>
    + core::ops::BitOr<Output = Self>
    + core::ops::BitOrAssign
    + core::ops::BitOr<Self::Element, Output = Self>
    + core::ops::BitOrAssign<Self::Element>
    + core::ops::BitXor<Output = Self>
    + core::ops::BitXorAssign
    + core::ops::BitXor<Self::Element, Output = Self>
    + core::ops::BitXorAssign<Self::Element>
    + core::ops::Not<Output = Self>
{
    #[doc = "Compare two vectors element-wise for equality.\n\nReturns a mask where each element is all ones if the corresponding elements are equal, and all zeroes if not."]
    fn simd_eq(self, rhs: impl SimdInto<Self, S>) -> Self::Mask;
    #[doc = "Returns true if any elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_true(self) -> bool;
    #[doc = "Returns true if all elements in this mask are true (all ones).\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_true(self) -> bool;
    #[doc = "Returns true if any elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!all_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn any_false(self) -> bool;
    #[doc = "Returns true if all elements in this mask are false (all zeroes).\n\nThis is logically equivalent to `!any_true`, but may be faster.\n\nBehavior on mask elements that are not all zeroes or all ones is unspecified. It may vary depending on architecture, feature level, the mask elements' width, the mask vector's width, or library version.\n\nThe behavior is also not guaranteed to be logically consistent if mask elements are not all zeroes or all ones. `any_true` may not return the same result as `!all_false`, and `all_true` may not return the same result as `!any_false`.\n\nThe [`select`](crate::Select::select) operation also has unspecified behavior for mask elements that are not all zeroes or all ones. That behavior may not match the behavior of this operation."]
    fn all_false(self) -> bool;
}
