// Copyright 2025 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

// This file is autogenerated by fearless_simd_gen

#![expect(
    unused_variables,
    clippy::todo,
    reason = "TODO: https://github.com/linebender/fearless_simd/issues/40"
)]
use crate::{Simd, SimdFrom, seal::Seal};
use crate::{
    f32x8, f64x4, i8x32, i16x16,
    i32x8, mask8x32, mask16x16,
    mask32x8, mask64x4, u8x32, u16x16, u32x8,
};
use core::arch::x86_64::*;
#[doc = r#" The SIMD token for the "AVX2" and "FMA" level."#]
#[derive(Clone, Copy, Debug)]
pub(super) struct Avx2 {
    pub avx2: crate::core_arch::x86_64::Avx2,
}
impl Avx2 {
    #[doc = r" Create a SIMD token."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" The AVX2 and FMA CPU feature must be available."]
    #[inline]
    pub(super) unsafe fn new_unchecked() -> Self {
        Avx2 {
            avx2: unsafe { crate::core_arch::x86_64::Avx2::new_unchecked() },
        }
    }
}
impl Seal for Avx2 {}
impl<S: Simd> SimdFrom<__m256, S> for f32x8<S> {
    #[inline(always)]
    fn simd_from(arch: __m256, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<f32x8<S>> for __m256 {
    #[inline(always)]
    fn from(value: f32x8<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for i8x32<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<i8x32<S>> for __m256i {
    #[inline(always)]
    fn from(value: i8x32<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for u8x32<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<u8x32<S>> for __m256i {
    #[inline(always)]
    fn from(value: u8x32<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for mask8x32<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<mask8x32<S>> for __m256i {
    #[inline(always)]
    fn from(value: mask8x32<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for i16x16<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<i16x16<S>> for __m256i {
    #[inline(always)]
    fn from(value: i16x16<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for u16x16<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<u16x16<S>> for __m256i {
    #[inline(always)]
    fn from(value: u16x16<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for mask16x16<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<mask16x16<S>> for __m256i {
    #[inline(always)]
    fn from(value: mask16x16<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for i32x8<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<i32x8<S>> for __m256i {
    #[inline(always)]
    fn from(value: i32x8<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for u32x8<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<u32x8<S>> for __m256i {
    #[inline(always)]
    fn from(value: u32x8<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for mask32x8<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<mask32x8<S>> for __m256i {
    #[inline(always)]
    fn from(value: mask32x8<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256d, S> for f64x4<S> {
    #[inline(always)]
    fn simd_from(arch: __m256d, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<f64x4<S>> for __m256d {
    #[inline(always)]
    fn from(value: f64x4<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
impl<S: Simd> SimdFrom<__m256i, S> for mask64x4<S> {
    #[inline(always)]
    fn simd_from(arch: __m256i, simd: S) -> Self {
        Self {
            val: unsafe { core::mem::transmute(arch) },
            simd,
        }
    }
}
impl<S: Simd> From<mask64x4<S>> for __m256i {
    #[inline(always)]
    fn from(value: mask64x4<S>) -> Self {
        unsafe { core::mem::transmute(value.val) }
    }
}
